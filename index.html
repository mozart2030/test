<script>
/* ================= Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„ØªØ¹Ø¯ÙŠÙ„ ÙˆØ§Ù„Ù…Ø±Ø§Ø¬Ø¹Ø© (Ù…Ø­Ø¯Ø«Ø©) ================= */
const API_MODEL = "gemini-2.5-flash-lite"; // Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ø£Ø³Ø±Ø¹ ÙˆØ§Ù„Ø£Ù‚Ù„ ØªÙƒÙ„ÙØ©
const API_BASE = "https://generativelanguage.googleapis.com/v1beta/models";
const MAX_CONCURRENCY = 8;             // Ø£Ù‚ØµÙ‰ ØªÙˆØ§Ø²ÙŠ (Ø³Ø±Ø¹Ø©)
const CHUNK_SIZE = 10000;              // Ø­Ø¬Ù… Ø§Ù„Ù…Ù‚Ø·Ø¹ 10000 Ø­Ø±Ù (Ù„ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø·Ù„Ø¨Ø§Øª)
const MAX_RETRIES = 5;
const STORAGE_KEY = 'geminiTranslatorState_V5'; 

/* ================== ÙƒÙˆØ¯ ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙˆØ§Ù„Ø¯ÙˆØ§Ù„ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© ================== */
const qs = id => document.getElementById(id);
const logBox = qs('logBox');
const startBtn = qs('startButton');
const clearBtn = qs('clearButton');

let epubFile = null, fewShot = [];

function writeLog(msg, type='info') {
  const logEntry = document.createElement('div');
  logEntry.className = `log-${type}`;
  logEntry.textContent = `[${new Date().toLocaleTimeString('ar-EG')}] ${msg}`;
  logBox.prepend(logEntry);
  if(logBox.children.length > 50) logBox.removeChild(logBox.lastChild);
}

function setProgress(percent, text) {
  qs('progressBar').style.width = percent + '%';
  qs('progressText').textContent = `${Math.round(percent)}% - ${text}`;
}

function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

function updateStartButton() {
    const key = qs('apiKey').value.trim();
    const file = qs('epubFile').files[0];
    const state = localStorage.getItem(STORAGE_KEY) ? JSON.parse(localStorage.getItem(STORAGE_KEY)) : null;
    
    if (!key || !file) {
        startBtn.textContent = 'Ø¨Ø¯Ø¡ Ø§Ù„ØªØ±Ø¬Ù…Ø© / Ø§Ø³ØªØ¦Ù†Ø§Ù';
        return;
    }
    
    if (state && state.filename === file.name && Array.isArray(state.chapters)) {
        const translatedCount = state.chapters.filter(c => c.translated).length;
        const totalChapters = state.chapters.length;

        if (translatedCount < totalChapters) {
            // Ø­Ø§Ù„Ø© Ø§Ø³ØªØ¦Ù†Ø§Ù
            startBtn.textContent = `Ø§Ø³ØªØ¦Ù†Ø§Ù Ø§Ù„ØªØ±Ø¬Ù…Ø© (${translatedCount}/${totalChapters})`;
            qs('downloadLink').style.display = 'none';
        } else {
            // Ø­Ø§Ù„Ø© Ø§ÙƒØªÙ…Ø§Ù„
            startBtn.textContent = 'Ø§ÙƒØªÙ…Ù„ Ø³Ø§Ø¨Ù‚Ø§Ù‹ (Ø§Ø¨Ø¯Ø£ Ù…Ù† Ø¬Ø¯ÙŠØ¯)';
            qs('downloadLink').style.display = 'inline-block';
        }
    } else {
        startBtn.textContent = 'Ø¨Ø¯Ø¡ Ø§Ù„ØªØ±Ø¬Ù…Ø© / Ø§Ø³ØªØ¦Ù†Ø§Ù';
        qs('downloadLink').style.display = 'none';
    }
}

function clearState() {
    localStorage.removeItem(STORAGE_KEY);
    qs('downloadLink').style.display = 'none';
    writeLog('ğŸ—‘ï¸ ØªÙ… Ù…Ø³Ø­ Ø­Ø§Ù„Ø© Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø©.', 'info');
    setProgress(0, 'ØªÙ… Ù…Ø³Ø­ Ø§Ù„Ø­Ø§Ù„Ø©.');
    location.reload(); 
}

window.addEventListener('load', updateStartButton);
qs('clearButton').addEventListener('click', clearState); // Ø±Ø¨Ø· Ø²Ø± Ø§Ù„Ù…Ø³Ø­

qs('epubFile').addEventListener('change', e => { epubFile = e.target.files[0]; writeLog('ğŸ“¥ Ø§Ø®ØªØ±Øª: ' + (epubFile ? epubFile.name : 'Ù„Ø§ Ø´ÙŠØ¡')); updateStartButton(); });
qs('apiKey').addEventListener('input', updateStartButton);
qs('fewFile').addEventListener('change', async e => {
  const f = e.target.files[0]; if(!f) { fewShot = []; return; }
  try {
    const txt = await f.text();
    const parsed = JSON.parse(txt);
    if(!Array.isArray(parsed)) { writeLog('âŒ Ù…Ù„Ù few-shot ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ù…ØµÙÙˆÙØ©', 'error'); return; }
    fewShot = parsed.filter(p => p && typeof p.en === 'string' && typeof p.ar === 'string');
    writeLog('âœ… Ø­Ù…Ù„Øª ' + fewShot.length + ' Ù†Ù…ÙˆØ°Ø¬ ØªØ±Ø¬Ù…Ø© (few-shot)');
  } catch(err){ writeLog('âŒ Ø®Ø·Ø£ Ù‚Ø±Ø§Ø¡Ø© few-shot: ' + err.message, 'error'); fewShot = []; }
});
qs('startButton').addEventListener('click', startWorkflow);

/* ------------------- Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ API Ù…Ø¹ Ø¥Ø¹Ø§Ø¯Ø© Ù…Ø­Ø§ÙˆÙ„Ø© Ø£Ø³Ù‘ÙŠØ© ------------------- */
async function callGemini(promptText) {
  const key = qs('apiKey').value.trim();
  if(!key) throw new Error('Ù…ÙØªØ§Ø­ API Ù…ÙÙ‚ÙˆØ¯');
  // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…ØªØºÙŠØ± API_MODEL
  const url = `${API_BASE}/${API_MODEL}:generateContent?key=${encodeURIComponent(key)}`;

  const payload = { contents: [{ parts: [{ text: promptText }] }] };

  let lastErr = null;
  for(let attempt=0; attempt < MAX_RETRIES; attempt++){
    try {
      const res = await fetch(url, { method: 'POST', headers: { 'Content-Type':'application/json' }, body: JSON.stringify(payload) });
      const j = await res.json().catch(()=>({}));
      if(res.ok){
        const cand = j?.candidates?.[0];
        if(cand?.content?.parts?.[0]?.text) return cand.content.parts[0].text;
        if(cand?.content?.text) return cand.content.text;
        throw new Error('Ø§Ø³ØªØ¬Ø§Ø¨Ø© ÙØ§Ø±ØºØ© Ø£Ùˆ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹Ø© Ù…Ù† API.');
      } else {
        lastErr = j?.error?.message || `HTTP ${res.status}`;
        if(res.status === 429 || res.status >= 500){
          const wait = (2 ** attempt) * 800 + Math.floor(Math.random()*400);
          writeLog(`âš ï¸ Ø±Ù…Ø² ${res.status} - Ø¥Ø¹Ø§Ø¯Ø© Ù…Ø­Ø§ÙˆÙ„Ø© #${attempt+1} Ø¨Ø¹Ø¯ ${Math.round(wait/1000)} Ø«`, 'error');
          await sleep(wait);
          continue;
        } else {
          throw new Error(lastErr);
        }
      }
    } catch(err){
      lastErr = err.message || String(err);
      const wait = (2 ** attempt) * 600 + Math.floor(Math.random()*300);
      writeLog(`âš ï¸ Ø®Ø·Ø£ Ø§ØªØµØ§Ù„: ${lastErr} â€” Ø¥Ø¹Ø§Ø¯Ø© Ù…Ø­Ø§ÙˆÙ„Ø© #${attempt+1} Ø¨Ø¹Ø¯ ${Math.round(wait/1000)} Ø«`, 'error');
      await sleep(wait);
    }
  }
  throw new Error('ØªØ¬Ø§ÙˆØ²Ù†Ø§ Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø§Ù„Ø§ØªØµØ§Ù„: ' + (lastErr||'unknown'));
}

/* ------------------- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…Ø­ØªÙˆÙŠØ§Øª EPUB (ÙŠØ¬Ø¨ ØªØ®Ø²ÙŠÙ† HTML) ------------------- */
async function extractChaptersFromEpub(fileBlob){
  setProgress(2, 'ÙŠÙÙƒ Ø¶ØºØ· EPUB ÙˆÙŠØ­Ø¯Ø¯ Ù…Ù„Ù Ø§Ù„Ù…Ø­ØªÙˆÙ‰ (OPF)...');
  if (typeof JSZip === 'undefined') throw new Error('Ù…ÙƒØªØ¨Ø© JSZip Ù„Ù… ØªÙØ­Ù…Ù‘Ù„.');
  const zip = await JSZip.loadAsync(fileBlob);
  const containerPath = 'META-INF/container.xml';
  let opfPath;

  if(zip.file(containerPath)) {
    const contTxt = await zip.file(containerPath).async('text');
    const contDoc = new DOMParser().parseFromString(contTxt, 'application/xml');
    opfPath = contDoc.querySelector('rootfile')?.getAttribute('full-path');
  } else {
    // Ù…Ø­Ø§ÙˆÙ„Ø© Ø¥ÙŠØ¬Ø§Ø¯ Ù…Ù„Ù OPF Ø¨Ø´ÙƒÙ„ Ø¨Ø¯ÙŠÙ„
    opfPath = Object.keys(zip.files).find(p => p.toLowerCase().endsWith('.opf'));
  }
  
  if(!opfPath) throw new Error('Ù„Ù… ÙŠÙØ¹Ø«Ø± Ø¹Ù„Ù‰ Ù…Ù„Ù OPF Ù„ØªØ­Ø¯ÙŠØ¯ ØªØ±ØªÙŠØ¨ Ø§Ù„ÙØµÙˆÙ„');

  return await readOpfAndCollect(zip, opfPath);
}

// Ø¯Ø§Ù„Ø© Ù‚Ø±Ø§Ø¡Ø© OPF - ØªØ®Ø²Ù† Ø§Ù„Ù€ HTML Ø§Ù„Ø®Ø§Ù…
async function readOpfAndCollect(zip, opfPath){
  setProgress(5, 'ÙŠÙ‚Ø±Ø£ content.opf ÙˆÙŠØ¬Ù…Ø¹ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ù„ÙØ§Øª ÙˆÙÙ‚ spine...');
  const opfTxt = await zip.file(opfPath).async('text');
  const opfDoc = new DOMParser().parseFromString(opfTxt, 'application/xml');

  const manifestItems = {};
  opfDoc.querySelectorAll('manifest > item').forEach(it=>{
    const id = it.getAttribute('id'), href = it.getAttribute('href');
    if(id && href) manifestItems[id] = href;
  });

  const spineItems = Array.from(opfDoc.querySelectorAll('spine > itemref')).map(it => it.getAttribute('idref')).filter(Boolean);
  const baseDir = opfPath.includes('/') ? opfPath.substring(0, opfPath.lastIndexOf('/')+1) : '';

  const chapters = [];
  for(const idref of spineItems){
    const href = manifestItems[idref];
    if(!href) continue;
    const full = baseDir + href;
    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ù…Ù„Ù ÙÙŠ Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„ÙƒØ§Ù…Ù„ Ø£Ùˆ Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ù†Ø³Ø¨ÙŠ
    const fileEntry = zip.file(full) || zip.file(href); 
    if(!fileEntry) continue;
    const rawHtml = await fileEntry.async('text');
    
    // Ø§Ù„ØªØºÙŠÙŠØ± Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ: Ù†Ø®Ø²Ù† rawHtml ÙƒØ§Ù…Ù„Ø§Ù‹
    chapters.push({ href: full, rawHtml: rawHtml, translatedBody: null }); 
  }

  if(chapters.length === 0) throw new Error('Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ ÙØµÙˆÙ„ Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬');
  writeLog('âœ… ØªÙ… Ø§Ø³ØªØ®Ø±Ø§Ø¬ ' + chapters.length + ' Ø¹Ù†ØµØ± (ÙØµÙ„/Ù‚Ø³Ù…) Ù…Ù† Ø§Ù„ÙƒØªØ§Ø¨', 'ok');
  return { zip, opfPath, chapters };
}

/* ------------------- Ø¯Ø§Ù„Ø© Ø­ÙØ¸ Ø§Ù„Ø­Ø§Ù„Ø© ÙÙŠ Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø­Ù„ÙŠ (Ù…Ø¹Ø²Ø²Ø©) ------------------- */
function saveState(data) {
  try {
    // 1. ØªØ¬Ù‡ÙŠØ² Ø§Ù„Ø­Ø§Ù„Ø© Ù„Ù„Ø­ÙØ¸ ÙÙŠ localStorage (ØªØ®Ø²ÙŠÙ† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙˆØµÙÙŠØ© ÙÙ‚Ø·)
    const stateToSave = {
        filename: data.filename,
        apiKey: data.apiKey,
        opfPath: data.opfPath,
        chapters: data.chapters.map(c => ({ 
            href: c.href, 
            // Ù†Ø¹ØªØ¨Ø± Ø§Ù„ÙØµÙ„ Ù…ØªØ±Ø¬Ù…Ø§Ù‹ Ø¥Ø°Ø§ ÙƒØ§Ù† translatedBody Ù„ÙŠØ³ ÙØ§Ø±ØºØ§Ù‹ ÙˆÙ„ÙŠØ³ ALREADY_TRANSLATED
            translated: c.translatedBody !== null && c.translatedBody !== 'ALREADY_TRANSLATED' 
        }))
    };
    
    // 2. **Ø§Ù„ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ø§Ø³Ù…:** Ø­ÙØ¸ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ù…ØªØ±Ø¬Ù… ÙÙŠ ÙƒØ§Ø¦Ù† JSZip ÙÙŠ Ø§Ù„Ø°Ø§ÙƒØ±Ø©
    data.chapters.forEach(ch => {
        // Ù†ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„ÙØµÙ„ ØªÙØ±Ø¬Ù… Ø­Ø¯ÙŠØ«Ù‹Ø§ (ÙˆÙ„ÙŠØ³ Ù…Ø¬Ø±Ø¯ ØªÙ… ØªÙ…ÙŠÙŠØ²Ù‡ Ù„Ù„Ø§Ø³ØªØ¦Ù†Ø§Ù)
        if (ch.translatedBody && ch.translatedBody !== 'ALREADY_TRANSLATED' && ch.rawHtml) {
            // Ù†Ø£Ø®Ø° Ø§Ù„Ù€ HTML Ø§Ù„Ø£ØµÙ„ÙŠ ÙˆÙ†Ø³ØªØ¨Ø¯Ù„ Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù€ <body>
            const bodyMatch = ch.rawHtml.match(/<body[^>]*>([\s\S]*)<\/body>/i);
            
            if (bodyMatch) {
                let finalHtml = ch.rawHtml.replace(bodyMatch[1], ch.translatedBody);
                
                // Ø¥Ø¶Ø§ÙØ© Ø®Ø§ØµÙŠØ© dir="rtl" Ùˆ lang="ar" Ù„Ù„Ù€ <html> Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø©
                if (!finalHtml.includes('dir="rtl"')) {
                     // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† ÙˆØ³Ù… <html> Ø§Ù„Ø£ÙˆÙ„ÙŠ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø¥Ù„ÙŠÙ‡
                     finalHtml = finalHtml.replace(/<html/i, '<html dir="rtl" lang="ar"');
                }
                
                // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ù„Ù ÙÙŠ ÙƒØ§Ø¦Ù† Ø§Ù„Ù€ Zip.
                data.zip.file(ch.href, finalHtml);
            }
            // 3. Ù…Ø³Ø­ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù…ØªØ±Ø¬Ù… Ù…Ù† Ù…ØªØºÙŠØ± Ø§Ù„ÙØµÙ„ Ù„ØªØ®ÙÙŠÙ Ø§Ù„Ø°Ø§ÙƒØ±Ø©
            ch.translatedBody = 'ALREADY_TRANSLATED'; // Ù†Ø¶Ø¹Ù‡ ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ø­Ø§Ù„Ø© Ù„Ù…Ù†Ø¹Ù‡ Ù…Ù† Ø§Ù„ØªØ±Ø¬Ù…Ø© Ù…Ø¬Ø¯Ø¯Ø§Ù‹ ÙˆÙ„ØªØ®ÙÙŠÙ Ø§Ù„Ø°Ø§ÙƒØ±Ø©
        }
    });

    localStorage.setItem(STORAGE_KEY, JSON.stringify(stateToSave));
    updateStartButton();
  } catch(e) {
    writeLog('âš ï¸ ÙØ´Ù„ Ø­ÙØ¸ Ø§Ù„Ø­Ø§Ù„Ø© ÙÙŠ LocalStorage. ' + e.message, 'error');
  }
}

/* ------------------- ØªØ±Ø¬Ù…Ø© ÙØµÙ„ (Ù…Ø¹ Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ HTML) ------------------- */
async function translateChapterWithChunks(chapter, chapterIndex, totalChapters){
  if (chapter.translatedBody === 'ALREADY_TRANSLATED') return; 

  const originalHtml = chapter.rawHtml || '';
  const bodyMatch = originalHtml.match(/<body[^>]*>([\s\S]*)<\/body>/i);
  let bodyInner = bodyMatch ? bodyMatch[1] : originalHtml;
  
  // ØªÙ‚Ø³ÙŠÙ… Ø°ÙƒÙŠ: Ø¹Ù†Ø¯ Ù†Ù‡Ø§ÙŠØ© ÙˆØ³ÙˆÙ… HTML Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ù„ØªØ¬Ù†Ø¨ Ø§Ù„ÙƒØ³Ø±
  const rawChunks = bodyInner.split(/(?<=<\/p>|<\/div>|<\/h[1-6]>|<\/blockquote>|\n\n)/g);
  
  // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ù‚Ø·Ø¹ Ø§Ù„ØµØºÙŠØ±Ø© Ù„ØªÙƒÙˆÙŠÙ† "Chunks" Ø¨Ø­Ø¬Ù… 10000 Ø­Ø±Ù
  let consolidatedChunks = [];
  let currentChunk = "";
  for (let raw of rawChunks) {
      if ((currentChunk.length + raw.length) > CHUNK_SIZE && currentChunk.length > 0) { 
          consolidatedChunks.push(currentChunk);
          currentChunk = "";
      }
      currentChunk += raw;
  }
  if (currentChunk.trim()) consolidatedChunks.push(currentChunk);

  if(consolidatedChunks.length === 0) { chapter.translatedBody = bodyInner; return; }

  writeLog(`ğŸ” ÙØµÙ„ ${chapterIndex+1}/${totalChapters}: ${consolidatedChunks.length} Ø¬Ø²Ø¡ (Ø¨Ø­Ø¯ Ø£Ù‚ØµÙ‰ ${CHUNK_SIZE} Ø­Ø±Ù)`);

  const results = new Array(consolidatedChunks.length);
  let index = 0;

  async function worker(){
    while(true){
      const i = index++;
      if(i >= consolidatedChunks.length) break;
      const piece = consolidatedChunks[i];
      
      // Ø¨Ù†Ø§Ø¡ Ø§Ù„Ù€ Prompt
      let context = '';
      if (fewShot.length > 0) {
          context = "=== Ø£Ù…Ø«Ù„Ø© Few-Shot: ===\n" + fewShot.map(s => `[EN]: ${s.en.slice(0, 100).replace(/\n/g, ' ')}\n[AR]: ${s.ar.slice(0, 100).replace(/\n/g, ' ')}\n`).join('---\n');
      }

      let prompt = context + 
        "**Ø§Ù„Ø¯ÙˆØ± ÙˆØ§Ù„ØªØ¹Ù„ÙŠÙ…Ø§Øª:** Ø£Ù†Øª Ù…ØªØ±Ø¬Ù… Ø±ÙˆØ§ÙŠØ§Øª Ù…Ø­ØªØ±Ù Ù…ØªØ®ØµØµ ÙÙŠ Ø§Ù„Ø®ÙŠØ§Ù„ (Xianxia/Wuxia). Ù…Ù‡Ù…ØªÙƒ Ù‡ÙŠ ØªØ±Ø¬Ù…Ø© Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù†Øµ Ø¯Ø§Ø®Ù„ ÙˆØ³ÙˆÙ… HTML Ø§Ù„ØªØ§Ù„ÙŠØ© Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø§Ù„ÙØµØ­Ù‰.\n" +
        "**Ù‚ÙˆØ§Ø¹Ø¯ ØµØ§Ø±Ù…Ø©:**\n" +
        "1. **ÙŠØ¬Ø¨** Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø¬Ù…ÙŠØ¹ ÙˆØ³ÙˆÙ… HTML ÙƒÙ…Ø§ Ù‡ÙŠ Ø¨Ø§Ù„Ø¶Ø¨Ø· (Ù…Ø«Ù„ <p>, <div>, <b>, <a>) Ø¯ÙˆÙ† Ø¥Ø²Ø§Ù„ØªÙ‡Ø§ Ø£Ùˆ ØªØ¹Ø¯ÙŠÙ„Ù‡Ø§.\n" +
        "2. **ÙÙ‚Ø·** ØªØ±Ø¬Ù… Ø§Ù„Ù†Øµ Ø§Ù„Ù…Ù‚Ø±ÙˆØ¡ Ø¯Ø§Ø®Ù„ Ù‡Ø°Ù‡ Ø§Ù„ÙˆØ³ÙˆÙ….\n" +
        "3. Ù„Ø§ ØªØªØ±Ø¬Ù… Ø§Ù„Ù…ØµØ·Ù„Ø­Ø§Øª Ø£Ùˆ Ø§Ù„Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ø®Ø§ØµØ©.\n" +
        "4. **Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨:** ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬ Ù†Øµ HTML Ø§Ù„Ù…ØªØ±Ø¬Ù… ÙÙ‚Ø·ØŒ Ù…Ø·Ø§Ø¨Ù‚Ø§Ù‹ Ù„ÙˆØ³ÙˆÙ… Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ Ø¨Ø¯ÙˆÙ† Ø£ÙŠ Ø¥Ø¶Ø§ÙØ§Øª (Ù…Ø«Ù„ ```html Ø£Ùˆ Ø£ÙŠ Ù†Øµ ØªÙØ³ÙŠØ±ÙŠ). Ø§Ø¨Ø¯Ø£ Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬ Ù…Ø¨Ø§Ø´Ø±Ø©Ù‹ Ø¨Ø§Ù„ÙˆØ³Ù… Ø§Ù„Ø°ÙŠ ÙŠÙ„ÙŠ ÙˆØ³ÙˆÙ… Ø§Ù„ØªØ¹Ù„ÙŠÙ…Ø§ØªØŒ ÙˆØ£Ù†Ù‡Ù Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬ Ø¨Ø§Ù„ÙˆØ³Ù… Ø§Ù„Ø£Ø®ÙŠØ± ÙƒÙ…Ø§ ÙÙŠ Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„.\n\n" +
        "**Ù…Ù‚ØªØ·Ù HTML Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ ØªØ±Ø¬Ù…ØªÙ‡ Ø¨Ø¯Ù‚Ø©:**\n" + piece;

      try {
        const out = await callGemini(prompt);
        // ØªÙ†Ø¸ÙŠÙ Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ø§Ù„Ù†Ù…ÙˆØ°Ø¬
        results[i] = out.replace(/^```(html|xml)?\n/i, '').replace(/\n```$/i, '').trim() || '[ÙØ§Ø±Øº]'; 
        writeLog(`âœ… ØªØ±Ø¬Ù…Ø© Ø¬Ø²Ø¡ ${i+1}/${consolidatedChunks.length} ÙÙŠ ÙØµÙ„ ${chapterIndex+1}`);
      } catch(err){
        writeLog(`âŒ ÙØ´Ù„ ØªØ±Ø¬Ù…Ø© Ø¬Ø²Ø¡ ${i+1}: ${err.message}. Ø³ÙŠØªÙ… Ø§Ù„Ø§Ø­ØªÙØ§Ø¸ Ø¨Ø§Ù„Ù†Øµ Ø§Ù„Ø£ØµÙ„ÙŠ.`, 'error');
        results[i] = piece; // Ø§Ù„Ø§Ø­ØªÙØ§Ø¸ Ø¨Ù€ HTML Ø§Ù„Ø£ØµÙ„ÙŠ Ø¹Ù†Ø¯ Ø§Ù„ÙØ´Ù„
      }
      await sleep(100);
    }
  }

  // ØªØ´ØºÙŠÙ„ 8 Ø¹Ù…Ø§Ù„ Ø¨Ø§Ù„ØªÙˆØ§Ø²ÙŠ
  const workers = Array.from({length: MAX_CONCURRENCY}, () => worker());
  await Promise.all(workers);

  // ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙØµÙ„ Ø¨Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù…ØªØ±Ø¬Ù…
  chapter.translatedBody = results.join('\n');
}

/* ------------------- Ø¥Ø¹Ø§Ø¯Ø© Ø¨Ù†Ø§Ø¡ EPUB ------------------- */
async function buildTranslatedEpub(originalZip, chapters, title){
  setProgress(92, 'ÙŠØ¨Ù†ÙŠ Ù…Ù„Ù EPUB Ø§Ù„Ù…ØªØ±Ø¬Ù… ...');
  const out = new JSZip();
  out.file('mimetype', 'application/epub+zip', {compression: 'STORE'}); 

  // Ù†Ù†Ø³Ø® Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ù…Ù† Ù…Ù„Ù zip Ø§Ù„Ù…Ø­Ø¯Ø« Ø§Ù„Ø°ÙŠ ØªÙ… ØªØ®Ø²ÙŠÙ† Ø§Ù„ÙØµÙˆÙ„ Ø§Ù„Ù…ØªØ±Ø¬Ù…Ø© ÙÙŠÙ‡ ÙÙŠ saveState
  for(const path of Object.keys(originalZip.files)){
    const f = originalZip.file(path);
    if(!f) continue;
    
    const content = await f.async('uint8array');
    out.file(path, content);
  }

  const blob = await out.generateAsync({type:'blob', mimeType:'application/epub+zip'});
  return blob;
}

/* ------------------- Ø§Ù„Ù…Ø¬Ø±Ù‰ Ø§Ù„ÙƒØ§Ù…Ù„ Ù…Ø¹ Ù…Ù†Ø·Ù‚ Ø§Ù„Ø§Ø³ØªØ¦Ù†Ø§Ù Ø§Ù„Ù…ÙØ¹Ø²Ù‘ÙØ² ------------------- */
async function startWorkflow(){
  epubFile = qs('epubFile').files[0];

  try {
    if(!epubFile) { writeLog('âŒ Ù„Ù… ØªØ®ØªÙØ± Ù…Ù„Ù EPUB', 'error'); return; }
    const apiKey = qs('apiKey').value.trim();
    if(!apiKey) { writeLog('âŒ Ø£Ù„ØµÙ‚ Ù…ÙØªØ§Ø­ API Ø£ÙˆÙ„Ù‹Ø§', 'error'); return; }
    
    startBtn.disabled = true;
    setProgress(1, 'ÙŠØ¬Ù‡Ø² Ø§Ù„Ø¹Ù…Ù„ÙŠØ©...');
    
    let state = localStorage.getItem(STORAGE_KEY);
    state = state ? JSON.parse(state) : null;
    
    let initialChapterIndex = 0;
    let zip, opfPath, chapters;
    
    const isResuming = (state && state.filename === epubFile.name && Array.isArray(state.chapters));

    if (isResuming) {
        zip = await JSZip.loadAsync(epubFile);
        opfPath = state.opfPath;
        
        // 1. Ø¥Ø¹Ø§Ø¯Ø© Ø§Ø³ØªØ®Ù„Ø§Øµ Ø§Ù„Ù‡ÙŠÙƒÙ„ Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ù„ØªØ¶Ù…ÙŠÙ† rawHtml Ù…Ø±Ø© Ø£Ø®Ø±Ù‰
        const tempResult = await readOpfAndCollect(zip, opfPath);
        chapters = tempResult.chapters; 
        
        // 2. ØªØ·Ø¨ÙŠÙ‚ Ø­Ø§Ù„Ø© Ø§Ù„Ø§Ø³ØªØ¦Ù†Ø§Ù Ø¹Ù„Ù‰ Ø§Ù„Ù‡ÙŠÙƒÙ„ Ø§Ù„Ø¬Ø¯ÙŠØ¯
        state.chapters.forEach((c, i) => {
            if(c.translated && chapters[i]) {
                // Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ØªØ±Ø¬Ù…Ø§Ù‹ Ø³Ø§Ø¨Ù‚Ø§Ù‹ØŒ Ù†Ø¹ØªØ¨Ø±Ù‡ Ù…Ù†Ø¬Ø²Ø§Ù‹ (Ù„Ù„ØªØ®Ø·ÙŠ)
                chapters[i].translatedBody = 'ALREADY_TRANSLATED';
            }
        });

        initialChapterIndex = chapters.findIndex(c => c.translatedBody === null);
        if (initialChapterIndex === -1) initialChapterIndex = chapters.length;
        writeLog(`âœ… Ø§Ø³ØªØ¦Ù†Ø§Ù: ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø­Ø§Ù„Ø©ØŒ Ø§Ù„Ø¨Ø¯Ø¡ Ù…Ù† Ø§Ù„ÙØµÙ„ ${initialChapterIndex + 1} Ù…Ù† ${chapters.length}`, 'ok');
    } else {
        // Ø­Ø§Ù„Ø© Ø¨Ø¯Ø¡ Ø¬Ø¯ÙŠØ¯
        writeLog('ğŸ” ÙŠØ¨Ø¯Ø£ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„ÙƒØªØ§Ø¨...');
        const extractionResult = await extractChaptersFromEpub(epubFile);
        zip = extractionResult.zip; opfPath = extractionResult.opfPath; chapters = extractionResult.chapters;
        initialChapterIndex = 0;
        // Ø­ÙØ¸ Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø£ÙˆÙ„ÙŠØ© Ù…Ø¹ ÙƒØ§Ø¦Ù† zip
        saveState({ filename: epubFile.name, apiKey, opfPath, chapters, zip });
    }

    setProgress(8, 'Ù…Ø³ØªØ®Ù„Øµ Ø§Ù„ÙØµÙˆÙ„ â€” ÙŠØ¨Ø¯Ø£ Ø§Ù„ØªØ±Ø¬Ù…Ø© ÙØµÙ„Ù‹Ø§ ÙØµÙ„Ù‹Ø§');
    
    const totalChapters = chapters.length;
    // Ø¹Ø¯Ø¯ Ø§Ù„ÙØµÙˆÙ„ Ø§Ù„ØªÙŠ ÙŠØ¬Ø¨ ØªØ±Ø¬Ù…ØªÙ‡Ø§ ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ø¬Ù„Ø³Ø©
    const remainingChapters = totalChapters - initialChapterIndex;
    // Ù„ØªØ¬Ù†Ø¨ Ø§Ù„Ù‚Ø³Ù…Ø© Ø¹Ù„Ù‰ ØµÙØ± Ø¥Ø°Ø§ ÙƒØ§Ù† initialChapterIndex ÙŠØ³Ø§ÙˆÙŠ totalChapters
    const divisor = remainingChapters > 0 ? remainingChapters : 1; 

    // Ø§Ù„ØªØ±Ø¬Ù…Ø© ÙˆØ§Ù„Ø§Ø³ØªØ¦Ù†Ø§Ù
    for(let i = initialChapterIndex; i < totalChapters; i++){
        // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„ÙØµÙ„ Ù‚Ø¯ ØªÙ… ØªÙ…ÙŠÙŠØ²Ù‡ ÙƒÙ€ 'ALREADY_TRANSLATED'ØŒ Ù†Ù†ØªÙ‚Ù„ Ø¹Ù†Ù‡
        if(chapters[i].translatedBody === 'ALREADY_TRANSLATED') continue; 
        
        // Ø­Ø³Ø§Ø¨ Ø§Ù„ØªÙ‚Ø¯Ù… Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„ÙØµÙˆÙ„ Ø§Ù„Ù…ØªØ¨Ù‚ÙŠØ© (Ù…Ù† 10% Ø¥Ù„Ù‰ 90%) â­ï¸ Ø§Ù„ØªØ­Ø³ÙŠÙ†
        const chaptersDoneInThisSession = i - initialChapterIndex; 
        const percent = 10 + Math.round((chaptersDoneInThisSession / divisor) * 80);

        setProgress(percent, `ØªØ±Ø¬Ù…Ø© ÙØµÙ„ ${i+1}/${totalChapters}`);
        
        await translateChapterWithChunks(chapters[i], i, totalChapters); 
        
        // Ø­ÙØ¸ Ø§Ù„Ø­Ø§Ù„Ø© Ø¨Ø¹Ø¯ ÙƒÙ„ ÙØµÙ„ ØªÙ… ØªØ±Ø¬Ù…ØªÙ‡
        saveState({ filename: epubFile.name, apiKey, opfPath, chapters, zip });
    }

    // Ø¥Ø¹Ø§Ø¯Ø© Ø¨Ù†Ø§Ø¡ Ø§Ù„ÙƒØªØ§Ø¨ Ø¨Ø¹Ø¯ Ø§ÙƒØªÙ…Ø§Ù„ Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙØµÙˆÙ„
    const title = epubFile.name.replace(/\.[^/.]+$/, '') + '_AR_Pro';
    const blob = await buildTranslatedEpub(zip, chapters, title);

    // Ø¥ØªØ§Ø­Ø© Ø±Ø§Ø¨Ø· Ø§Ù„ØªØ­Ù…ÙŠÙ„
    const url = URL.createObjectURL(blob);
    const a = qs('downloadLink'); a.href = url; a.download = title + '.epub'; a.style.display = 'inline-block';
    a.textContent = 'â¬‡ï¸ ØªÙ†Ø²ÙŠÙ„ EPUB Ø§Ù„Ù…ØªØ±Ø¬Ù…: ' + a.download;
    
    setProgress(100, 'Ø§ÙƒØªÙ…Ù„ â€” Ø§Ù†Ù‚Ø± ØªÙ†Ø²ÙŠÙ„');
    writeLog('ğŸ‰ Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø¢Ù„ÙŠØ© Ù„Ù€ ' + totalChapters + ' ÙØµÙ„ â€” ÙŠÙ…ÙƒÙ†Ùƒ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø¢Ù†', 'ok');
    localStorage.removeItem(STORAGE_KEY); // Ø¥Ø²Ø§Ù„Ø© Ø­Ø§Ù„Ø© Ø§Ù„Ø§Ø³ØªØ¦Ù†Ø§Ù Ø§Ù„Ù…ÙƒØªÙ…Ù„Ø©
    
  } catch(err){
    writeLog('âŒ ÙØ´Ù„ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©: ' + (err.message || err), 'error');
    setProgress(0, 'ÙØ´Ù„');
  } finally {
    startBtn.disabled = false;
    updateStartButton();
  }
}
</script>
