<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Ù…ØªØ±Ø¬Ù… EPUB Ø§Ø­ØªØ±Ø§ÙÙŠ â€” Gemini PWA</title>
  
  <link rel="manifest" href="manifest.json">
  
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        // ØªØ£ÙƒØ¯ Ø£Ù† sw.js Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ Ù†ÙØ³ Ø§Ù„Ù…Ø¬Ù„Ø¯
        navigator.serviceWorker.register('sw.js')
          .then(reg => console.log('âœ… ØªÙ… ØªØ³Ø¬ÙŠÙ„ Service Worker Ø¨Ù†Ø¬Ø§Ø­.'))
          .catch(err => console.error('âŒ ÙØ´Ù„ ØªØ³Ø¬ÙŠÙ„ Service Worker:', err));
      });
    }
  </script>
  
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <style>
    body{font-family:system-ui, "Amiri", serif;background:#f5f7fb;padding:18px}
    .card{max-width:980px;margin:0 auto;background:white;padding:18px;border-radius:12px;box-shadow:0 10px 30px rgba(2,6,23,0.06)}
    h1{color:#0f5bd8}
    label{display:block;margin:8px 0;font-weight:600}
    input[type=text], input[type=file], button{width:100%;padding:12px;margin-bottom:12px;border:1px solid #ccc;border-radius:8px;box-sizing:border-box}
    button{background:#0f5bd8;color:white;cursor:pointer;font-weight:700;border:none;transition:background 0.3s}
    button:hover{background:#0d4aa6}
    button:disabled{background:#a0a0a0;cursor:not-allowed}
    #progressBar{width:0%;height:10px;background:#0f5bd8;border-radius:5px;transition:width 0.3s}
    #progressContainer{background:#e0e0e0;border-radius:5px;margin-bottom:15px}
    #logBox{max-height:200px;overflow-y:scroll;background:#f0f0f0;padding:10px;border-radius:8px;border:1px solid #ddd;font-size:14px;line-height:1.4;margin-top:10px;text-align:left}
    .log-info{color:#333}.log-error{color:#d9534f}.log-ok{color:#5cb85c}
    #downloadLink{display:none;background:#5cb85c;text-decoration:none;text-align:center;padding:12px;color:white;border-radius:8px;font-weight:700}
    #downloadLink:hover{background:#4cae4c}
    .file-input-wrapper{position:relative;overflow:hidden;display:inline-block}
    .file-input-wrapper input[type=file]{position:absolute;left:0;top:0;opacity:0;cursor:pointer}
    .file-input-wrapper button{display:block;padding:12px;background:#17a2b8;color:white;border-radius:8px;font-weight:700;border:none;transition:background 0.3s}
    .file-input-wrapper button:hover{background:#138496}
    .file-input-wrapper label{margin:0}
  </style>
</head>
<body>

<div class="card">
  <h1>Ù…ØªØ±Ø¬Ù… EPUB Ø§Ø­ØªØ±Ø§ÙÙŠ â€” Gemini PWA</h1>
  
  <p>Ù‡Ø°Ù‡ Ø§Ù„Ø£Ø¯Ø§Ø© ØªØ³ØªØ®Ø¯Ù… Gemini API Ù„ØªØ±Ø¬Ù…Ø© Ù…Ù„ÙØ§Øª EPUB Ø¨Ø´ÙƒÙ„ Ù…ØªÙˆØ§Ø²ÙŠØŒ Ù…Ø¹ Ø¯Ø¹Ù… Ø§Ù„Ø§Ø³ØªØ¦Ù†Ø§Ù Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù„Ø¶Ù…Ø§Ù† Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„ÙƒØªØ¨ Ø§Ù„Ø·ÙˆÙŠÙ„Ø©.</p>

  <label for="apiKey">Ù…ÙØªØ§Ø­ Gemini API:</label>
  <input type="text" id="apiKey" placeholder="Ø§Ø¯Ø®Ù„ Ù…ÙØªØ§Ø­ API Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ (Ù…Ø«Ø§Ù„: AIzaSy...)">

  <label for="epubFile">Ù…Ù„Ù EPUB Ù„Ù„ØªØ±Ø¬Ù…Ø©:</label>
  <input type="file" id="epubFile" accept=".epub">
  
  <label for="fewFile">Ù…Ù„Ù Few-Shot (Ø§Ø®ØªÙŠØ§Ø±ÙŠ Ù„ØªØ¹Ù„ÙŠÙ… Ø£Ø³Ù„ÙˆØ¨ Ø§Ù„ØªØ±Ø¬Ù…Ø©):</label>
  <input type="file" id="fewFile" accept=".json">

  <button id="startButton" onclick="startTranslation()">Ø¨Ø¯Ø¡ Ø§Ù„ØªØ±Ø¬Ù…Ø© / Ø§Ø³ØªØ¦Ù†Ø§Ù</button>
  <button id="clearButton" onclick="clearState()">Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ØªØ±Ø¬Ù…Ø© ÙˆÙ…Ø³Ø­ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª</button>

  <div id="progressContainer">
    <div id="progressBar"></div>
  </div>
  <div id="progressText">ÙÙŠ Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„Ø¨Ø¯Ø¡...</div>

  <a id="downloadLink"></a>

  <div id="logBox"></div>
</div>

<script>
  // Ø§Ù„Ø«ÙˆØ§Ø¨Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
  const MAX_CONCURRENCY = 8; // Ø¹Ø¯Ø¯ Ø·Ù„Ø¨Ø§Øª API Ø§Ù„Ù…ØªÙˆØ§Ø²ÙŠØ©
  const MAX_RETRIES = 5;     // Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø¹Ù†Ø¯ ÙØ´Ù„ Ø·Ù„Ø¨ API
  const SAFE_CHAR_PER_CHUNK = 10000; // Ø§Ù„Ø­Ø¬Ù… Ø§Ù„Ø¢Ù…Ù† Ù„Ù„Ù€ Prompt (Ø£Ù‚Ù„ Ù…Ù† Ø­Ø¯ Gemini)
  const STORAGE_KEY = 'epubTranslationState';
  let isTranslating = false;
  let fewShot = [];
  let zip; // Ù…ØªØºÙŠØ± Ø¹Ø§Ù„Ù…ÙŠ Ù„Ù…Ù„Ù Ø§Ù„Ù€ ZIP

  // Ø¯ÙˆØ§Ù„ Ù…Ø³Ø§Ø¹Ø¯Ø©
  const qs = (id) => document.getElementById(id);
  const writeLog = (message, type = 'info') => {
    const logBox = qs('logBox');
    const logEntry = document.createElement('div');
    logEntry.className = `log-${type}`;
    logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
    logBox.prepend(logEntry);
    if(logBox.children.length > 50) logBox.removeChild(logBox.lastChild);
  };
  const setProgress = (percent, text) => {
    qs('progressBar').style.width = percent + '%';
    qs('progressText').textContent = text;
  };
  const saveState = (state) => {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
  };
  const loadState = () => {
    const state = localStorage.getItem(STORAGE_KEY);
    return state ? JSON.parse(state) : null;
  };
  const clearState = () => {
    localStorage.removeItem(STORAGE_KEY);
    qs('downloadLink').style.display = 'none';
    writeLog('ğŸ—‘ï¸ ØªÙ… Ù…Ø³Ø­ Ø­Ø§Ù„Ø© Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø©.', 'info');
    setProgress(0, 'ØªÙ… Ù…Ø³Ø­ Ø§Ù„Ø­Ø§Ù„Ø©.');
    location.reload(); // Ù„Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„ÙˆØ§Ø¬Ù‡Ø©
  };

  // ----------------------------------------------------
  // 1. Ù…Ù†Ø·Ù‚ ØªØ¬Ø²Ø¦Ø© Ø§Ù„Ù†Øµ Ø§Ù„Ø¢Ù…Ù† (Ù„Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø³ÙŠØ§Ù‚ Ø§Ù„Ø¬Ù…Ù„Ø©)
  // ----------------------------------------------------
  const safeCut = (text) => {
    const chunks = [];
    let currentPos = 0;
    while(currentPos < text.length) {
        let chunkSize = Math.min(SAFE_CHAR_PER_CHUNK, text.length - currentPos);
        let chunk = text.substring(currentPos, currentPos + chunkSize);
        
        // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø­Ø¬Ù… Ø§Ù„Ù…Ù‚Ø·Ø¹ Ù‡Ùˆ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ØŒ Ù†Ø­Ø§ÙˆÙ„ Ù‚Ø·Ø¹Ù‡ Ø¹Ù†Ø¯ Ù†Ù‡Ø§ÙŠØ© Ø¬Ù…Ù„Ø© Ø£Ùˆ ÙÙ‚Ø±Ø©
        if (chunkSize === SAFE_CHAR_PER_CHUNK && currentPos + chunkSize < text.length) {
            
            // Ù†Ø¨Ø¯Ø£ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ù†Ù‚Ø·Ø© Ù‚Ø·Ø¹ Ø¢Ù…Ù†Ø© Ù…Ù† Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ù…Ù‚Ø·Ø¹ (90% Ù…Ù† Ø§Ù„Ø­Ø¬Ù… Ø§Ù„Ø¢Ù…Ù†)
            const searchStart = Math.floor(SAFE_CHAR_PER_CHUNK * 0.9);
            let safeCutIndex = -1;
            
            // Ù†Ø¨Ø­Ø« Ø¹Ù† Ø£Ù‚Ø±Ø¨ Ø¹Ù„Ø§Ù…Ø§Øª ØªØ±Ù‚ÙŠÙ… Ø±Ø¦ÙŠØ³ÙŠØ© Ù„Ù„Ø®Ù„Ù:
            let lastPeriod = chunk.lastIndexOf('.', SAFE_CHAR_PER_CHUNK);
            let lastExclamation = chunk.lastIndexOf('!', SAFE_CHAR_PER_CHUNK);
            let lastQuestion = chunk.lastIndexOf('?', SAFE_CHAR_PER_CHUNK);
            let lastNewline = chunk.lastIndexOf('\n', SAFE_CHAR_PER_CHUNK);

            // Ù†Ø£Ø®Ø° Ø§Ù„Ø£Ø¨Ø¹Ø¯ Ø¨ÙŠÙ† Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„ØªØ±Ù‚ÙŠÙ… (Ù„Ø¬Ø¹Ù„ Ø§Ù„Ù…Ù‚Ø·Ø¹ Ø£ÙƒØ¨Ø± Ù…Ø§ ÙŠÙ…ÙƒÙ†)
            safeCutIndex = Math.max(lastPeriod, lastExclamation, lastQuestion, lastNewline);
            
            // Ø¥Ø°Ø§ ÙˆØ¬Ø¯Ù†Ø§ Ø¹Ù„Ø§Ù…Ø© ØªØ±Ù‚ÙŠÙ… Ø¨Ø¹Ø¯ Ù†Ù‚Ø·Ø© Ø§Ù„Ø¨Ø­Ø« Ø§Ù„Ø¢Ù…Ù†Ø© (90%)ØŒ Ù†Ø³ØªØ®Ø¯Ù…Ù‡Ø§
            if (safeCutIndex >= searchStart) {
                chunkSize = safeCutIndex + 1; // Ù†Ø¶ÙŠÙ 1 Ù„ØªØ¶Ù…ÙŠÙ† Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ±Ù‚ÙŠÙ…
                chunk = text.substring(currentPos, currentPos + chunkSize);
            }
        }
        
        chunks.push(chunk);
        currentPos += chunkSize;
    }
    return chunks;
  };

  // ----------------------------------------------------
  // 2. Ø¯Ø§Ù„Ø© Ø·Ù„Ø¨ API Ù…Ø¹ Ø¥Ø¹Ø§Ø¯Ø© Ù…Ø­Ø§ÙˆÙ„Ø© Ø£Ø³Ù‘ÙŠØ© (Exponential Backoff)
  // ----------------------------------------------------
  const callGemini = async (prompt, retryCount = 0) => {
    const apiKey = qs('apiKey').value;
    if (!apiKey) throw new Error("Ù…ÙØªØ§Ø­ API ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯.");
    
    const delay = Math.pow(2, retryCount) * 1000 + (Math.random() * 1000); // 1s, 2s, 4s, 8s, ...

    await new Promise(resolve => setTimeout(resolve, delay)); // Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„ØªØ£Ø®ÙŠØ± (ØµÙØ± ÙÙŠ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰)

    try {
        const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`;
        const response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                contents: [{ role: "user", parts: [{ text: prompt }] }],
                config: { temperature: 0.1, maxOutputTokens: 2000 }
            })
        });

        if (response.status === 429) { // Rate Limit
            if (retryCount < MAX_RETRIES) {
                writeLog(`âš ï¸ ØªØ¬Ø§ÙˆØ² Ø­Ø¯ÙˆØ¯ Ø§Ù„Ù…Ø¹Ø¯Ù„ (429). Ø¥Ø¹Ø§Ø¯Ø© Ù…Ø­Ø§ÙˆÙ„Ø© Ø±Ù‚Ù… ${retryCount + 1} Ø¨Ø¹Ø¯ ${Math.round(delay / 1000)} Ø«ÙˆØ§Ù†Ù...`, 'error');
                return await callGemini(prompt, retryCount + 1); // Ø¥Ø¹Ø§Ø¯Ø© Ù…Ø­Ø§ÙˆÙ„Ø©
            } else {
                throw new Error("ØªØ¬Ø§ÙˆØ² Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø¨Ø³Ø¨Ø¨ ØªØ¬Ø§ÙˆØ² Ø­Ø¯ÙˆØ¯ Ø§Ù„Ù…Ø¹Ø¯Ù„ (429).");
            }
        }
        
        if (!response.ok) {
            const errorBody = await response.json().catch(() => ({}));
            const errorMessage = errorBody.error ? errorBody.error.message : response.statusText;
             if (response.status >= 500 && retryCount < MAX_RETRIES) { // 5xx Server Error
                writeLog(`âš ï¸ Ø®Ø·Ø£ Ø®Ø§Ø¯Ù… (5xx). Ø¥Ø¹Ø§Ø¯Ø© Ù…Ø­Ø§ÙˆÙ„Ø© Ø±Ù‚Ù… ${retryCount + 1} Ø¨Ø¹Ø¯ ${Math.round(delay / 1000)} Ø«ÙˆØ§Ù†Ù...`, 'error');
                return await callGemini(prompt, retryCount + 1); // Ø¥Ø¹Ø§Ø¯Ø© Ù…Ø­Ø§ÙˆÙ„Ø©
            }
            throw new Error(`Ø®Ø·Ø£ API (${response.status}): ${errorMessage}`);
        }

        const data = await response.json();
        const text = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
        if (!text) throw new Error("Ø§Ø³ØªØ¬Ø§Ø¨Ø© ÙØ§Ø±ØºØ© Ø£Ùˆ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹Ø© Ù…Ù† API.");
        return text;

    } catch (error) {
        if (retryCount < MAX_RETRIES && (error.message.includes('Failed to fetch') || error.message.includes('408'))) {
            // Ù…Ø­Ø§ÙˆÙ„Ø© Ø¥Ø¹Ø§Ø¯Ø© ÙÙŠ Ø­Ø§Ù„Ø© Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ© Ø£Ùˆ Ù…Ù‡Ù„Ø© (408)
            writeLog(`âš ï¸ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ©. Ø¥Ø¹Ø§Ø¯Ø© Ù…Ø­Ø§ÙˆÙ„Ø© Ø±Ù‚Ù… ${retryCount + 1} Ø¨Ø¹Ø¯ ${Math.round(delay / 1000)} Ø«ÙˆØ§Ù†Ù...`, 'error');
            return await callGemini(prompt, retryCount + 1);
        }
        throw error;
    }
  };

  // ----------------------------------------------------
  // 3. Ø¯Ø§Ù„Ø© ØªØ±Ø¬Ù…Ø© Ø§Ù„ÙØµÙ„ Ø¨ØªÙ‚Ø³ÙŠÙ…Ù‡ Ø¥Ù„Ù‰ Ù…Ù‚Ø§Ø·Ø¹ Ù…ØªÙˆØ§Ø²ÙŠØ©
  // ----------------------------------------------------
  const translateChapterWithChunks = async (ch, chapterIndex, totalChapters) => {
    // âš ï¸ ÙŠØ¬Ø¨ Ø£Ù„Ø§ ØªØªÙ… Ø§Ù„ØªØ±Ø¬Ù…Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù†Øµ Ø§Ù„Ù…ØªØ±Ø¬Ù… Ù…ÙˆØ¬ÙˆØ¯Ù‹Ø§ Ø¨Ø§Ù„ÙØ¹Ù„ (Ù„Ù„Ø§Ø³ØªØ¦Ù†Ø§Ù)
    if (ch.translatedText && ch.translatedText.trim() !== '') {
        writeLog(`â­ï¸ ØªØ¬Ø§ÙˆØ² Ø§Ù„ÙØµÙ„ ${chapterIndex + 1}/${totalChapters} (Ù…ØªØ±Ø¬Ù… Ø¨Ø§Ù„ÙØ¹Ù„).`, 'info');
        return;
    }

    const rawText = ch.rawText;
    const chunks = safeCut(rawText);
    const translatedChunks = new Array(chunks.length).fill(null);
    let successfulChunks = 0;
    let failedChunks = 0;
    
    // Ø¨Ù†Ø§Ø¡ Ø§Ù„Ù€ Prompt Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ
    const systemInstruction = `Ø£Ù†Øª Ù…ØªØ±Ø¬Ù… Ø§Ø­ØªØ±Ø§ÙÙŠ Ù„Ø±ÙˆØ§ÙŠØ§Øª Ø§Ù„Ø³Ù„Ø§Ù„Ø§Øª Ø§Ù„Ø®ÙŠØ§Ù„ÙŠØ© (Xianxia/Wuxia). 
    Ù…Ù‡Ù…ØªÙƒ Ù‡ÙŠ ØªØ±Ø¬Ù…Ø© Ø§Ù„Ù†Øµ Ø§Ù„ØªØ§Ù„ÙŠ Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø§Ù„ÙØµØ­Ù‰ Ù…Ø¹ Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ø³Ù„ÙˆØ¨ Ø§Ù„Ù‚ØµØµÙŠ Ø§Ù„Ø£ØµÙ„ÙŠ.
    **Ø§Ù„Ù‚ÙˆØ§Ø¹Ø¯:**
    1. Ù„Ø§ ØªÙ‚Ù… Ø¨ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ø®Ø§ØµØ©ØŒ Ø§Ù„Ù…ØµØ·Ù„Ø­Ø§Øª Ø§Ù„ØªÙ‚Ù†ÙŠØ© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©ØŒ Ø£Ùˆ Ø§Ù„ÙˆØ­Ø¯Ø§Øª (Ù…Ø«Ù„: GustavØŒ KiloØŒ Evolver).
    2. Ù„Ø§ ØªØ¶Ù Ø£ÙŠ Ø´Ø±Ø­ Ø£Ùˆ Ù…Ù‚Ø¯Ù…Ø© Ø£Ùˆ Ø®Ø§ØªÙ…Ø© Ù„Ù„ØªØ±Ø¬Ù…Ø©.
    3. Ø­Ø§ÙØ¸ Ø¹Ù„Ù‰ ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ÙÙ‚Ø±Ø§Øª Ø§Ù„Ø£ØµÙ„ÙŠØ© (Ù„Ø§ ØªØ¯Ù…Ø¬ Ø£Ùˆ ØªÙ‚Ø³Ù… Ø§Ù„ÙÙ‚Ø±Ø§Øª).
    
    **Ø£Ù…Ø«Ù„Ø© Few-Shot (Ù„Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§ØªØ³Ø§Ù‚ Ø§Ù„Ù…ØµØ·Ù„Ø­Ø§Øª):**
    ${JSON.stringify(fewShot)}`;

    const worker = async (index) => {
        const chunk = chunks[index];
        const prompt = `${systemInstruction}\n\n**Ø§Ù„Ù†Øµ Ø§Ù„Ø£ØµÙ„ÙŠ Ù„Ù„ØªØ±Ø¬Ù…Ø©:**\n${chunk}`;
        
        try {
            const translated = await callGemini(prompt);
            translatedChunks[index] = translated.trim();
            successfulChunks++;
            writeLog(`âœ… Ø§ÙƒØªÙ…Ù„ Ø¬Ø²Ø¡ ${successfulChunks}/${chunks.length} Ù…Ù† Ø§Ù„ÙØµÙ„ ${chapterIndex + 1}`, 'info');
        } catch (error) {
            translatedChunks[index] = ``;
            failedChunks++;
            writeLog(`âŒ ÙØ´Ù„ ØªØ±Ø¬Ù…Ø© Ø¬Ø²Ø¡ Ù…Ù† Ø§Ù„ÙØµÙ„ ${chapterIndex + 1}: ${error.message}`, 'error');
            // Ø±Ù…ÙŠ Ø§Ù„Ø®Ø·Ø£ Ù„ØªÙˆÙ‚ÙŠÙ Ø§Ù„Ø­Ù„Ù‚Ø© Ø§Ù„Ù…ØªÙˆØ§Ø²ÙŠØ© (Ù„Ù„Ø³Ù…Ø§Ø­ Ø¨Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©)
            throw error; 
        }
    };

    let allChunksSucceeded = false;
    let attempt = 0;
    while(attempt < MAX_RETRIES) {
        attempt++;
        const currentPromises = [];
        let runningWorkers = 0;

        for (let i = 0; i < chunks.length; i++) {
            // ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ù…Ù‚Ø§Ø·Ø¹ Ø§Ù„ØªÙŠ ØªÙ…Øª ØªØ±Ø¬Ù…ØªÙ‡Ø§ Ø¨Ù†Ø¬Ø§Ø­
            if (translatedChunks[i] && !translatedChunks[i].startsWith('
) { chapter.translated = ''; return; }

  const safeChars = SAFE_CHAR_PER_CHUNK;
  const pieces = [];
  let cursor = 0;
  while(cursor < text.length){
    // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¯Ø§Ù„Ø© Ø§Ù„Ù‚Ø·Ø¹ Ø§Ù„Ø°ÙƒÙŠØ©
    const cutIndex = safeCut(text, cursor, safeChars);
    const part = text.substring(cursor, cutIndex).trim();
    if(part) pieces.push(part);
    cursor = cutIndex;
    if(cursor === text.length && pieces.length === 0) break;
  }
  
  if(pieces.length === 0 && text.length > 0) pieces.push(text); // ÙÙŠ Ø­Ø§Ù„ ÙƒØ§Ù† Ø§Ù„Ù†Øµ Ø£ØµØºØ± Ù…Ù† Ø­Ø¯ Ø§Ù„Ù‚Ø·Ø¹

  writeLog(`ğŸ” ÙØµÙ„ ${chapterIndex+1} Ù…Ù† ${totalChapters}: ØªÙ‚Ø·ÙŠØ¹ Ø¥Ù„Ù‰ ${pieces.length} Ù…Ù‚Ø·Ø¹(Ø§Øª)`);

  const results = new Array(pieces.length);
  let index = 0;

  let context = '';
  // Ø¥Ø¶Ø§ÙØ© Ø£Ù…Ø«Ù„Ø© Few-Shot Ù„Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© ÙÙŠ ØªØ­Ø¯ÙŠØ¯ Ø£Ø³Ù„ÙˆØ¨ Ø§Ù„ØªØ±Ø¬Ù…Ø©
  if (fewShot.length > 0) {
      context += "=== Ø£Ù…Ø«Ù„Ø© Few-Shot Ù„Ù„ØªØ±Ø¬Ù…Ø© (ÙŠØ¬Ø¨ ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø£Ø³Ù„ÙˆØ¨) ===\n";
      // Ù†Ø­Ø¯Ø¯ 5 Ø£Ù…Ø«Ù„Ø© ÙƒØ­Ø¯ Ø£Ù‚ØµÙ‰ Ù„Ø¶Ù…Ø§Ù† Ø¹Ø¯Ù… ØªØ¬Ø§ÙˆØ² Ø­Ø¬Ù… Ø§Ù„Ù…Ø·Ø§Ù„Ø¨Ø©
      fewShot.slice(0, 5).forEach(sample => { 
          context += `[Ø§Ù„Ù†Øµ Ø§Ù„Ø£ØµÙ„ÙŠ]: ${sample.en.replace(/\n/g, ' ')}\n[Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©]: ${sample.ar.replace(/\n/g, ' ')}\n---\n`;
      });
      context += "\n";
  }

  async function worker(){
    while(true){
      const i = index++;
      if(i >= pieces.length) break;
      const piece = pieces[i];
      
      // Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ù…Ø¹Ø¯Ù„ Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø·Ù„Ø¨ (Prompt)
      let prompt = context + 
        "**Ø§Ù„Ø¯ÙˆØ± ÙˆØ§Ù„ØªØ¹Ù„ÙŠÙ…Ø§Øª:** Ø£Ù†Øª Ù…ØªØ±Ø¬Ù… Ø±ÙˆØ§Ø¦ÙŠ Ù…Ø­ØªØ±Ù Ù…ØªØ®ØµØµ ÙÙŠ ØªØ±Ø¬Ù…Ø© Ù‚ØµØµ ÙˆØ±ÙˆØ§ÙŠØ§Øª Ø§Ù„Ø®ÙŠØ§Ù„ (Xianxia/Wuxia). ØªØ±Ø¬Ù… Ø§Ù„Ù…Ù‚Ø·Ø¹ Ø§Ù„ØªØ§Ù„ÙŠ Ø¥Ù„Ù‰ Ø¹Ø±Ø¨ÙŠØ© ÙØµØ­Ù‰ ÙˆØ£Ø¯Ø¨ÙŠØ©. ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙƒ:\n" +
        "1. **Ø§Ù„Ø§ØªØ³Ø§Ù‚:** Ø·Ø¨Ù‚ Ø£Ø³Ù„ÙˆØ¨ Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ù…ÙˆØ¶Ø­ ÙÙŠ Ø£Ù…Ø«Ù„Ø© Few-Shot Ø£Ø¹Ù„Ø§Ù‡ Ø¨Ø¯Ù‚Ø©.\n" +
        "2. **Ø§Ù„Ù‡ÙŠÙƒÙ„ÙŠØ©:** Ø­Ø§ÙØ¸ Ø¹Ù„Ù‰ Ù‡ÙŠÙƒÙ„ Ø§Ù„ÙÙ‚Ø±Ø§Øª Ø§Ù„Ø£ØµÙ„ÙŠØ© Ø¨Ø§Ù„Ø¶Ø¨Ø· (Ù„Ø§ ØªØ¶ÙŠÙ Ø£Ùˆ ØªØ¯Ù…Ø¬ ÙÙ‚Ø±Ø§Øª).\n" +
        "3. **Ø§Ù„Ù…ØµØ·Ù„Ø­Ø§Øª:** Ù„Ø§ ØªØªØ±Ø¬Ù… Ø§Ù„Ù…ØµØ·Ù„Ø­Ø§Øª Ø§Ù„ØªÙ‚Ù†ÙŠØ© Ø£Ùˆ Ø§Ù„Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ø®Ø§ØµØ© (Ù…Ø«Ù„ Qi, Dantian, Core Formation, Ø£Ùˆ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ø£Ù…Ø§ÙƒÙ†/Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„ØµÙŠÙ†ÙŠØ©).\n\n" +
        "**Ø§Ù„Ù…Ù‚Ø·Ø¹ Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ ØªØ±Ø¬Ù…ØªÙ‡:**\n" + piece + "\n\n**Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©:**";

      try {
        const out = await callGemini(prompt);
        results[i] = out ? out.trim() : '[ÙØ§Ø±Øº]';
        writeLog(`âœ… ØªØ±Ø¬Ù…Ø© Ù…Ù‚Ø·Ø¹ ${i+1}/${pieces.length} ÙÙŠ ÙØµÙ„ ${chapterIndex+1}`);
      } catch(err){
        writeLog(`âŒ ÙØ´Ù„ ØªØ±Ø¬Ù…Ø© Ù…Ù‚Ø·Ø¹ ${i+1} ÙÙŠ ÙØµÙ„ ${chapterIndex+1}: ${err.message}`, 'error');
        results[i] = '[Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ±Ø¬Ù…Ø© - Ø³ÙŠØªÙ… Ø¥Ø¯Ø±Ø§Ø¬Ù‡ ÙƒÙ†Øµ Ø£ØµÙ„ÙŠ ÙÙŠ EPUB]'; // ÙˆØ¶Ø¹ Ø¹Ù„Ø§Ù…Ø© Ø®Ø·Ø£
      }
      await sleep(120);
    }
  }

  // ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¹Ù…Ø§Ù„ Ø¨Ø§Ù„ØªÙˆØ§Ø²ÙŠ
  const workers = Array.from({length: MAX_CONCURRENCY}, () => worker());
  await Promise.all(workers);

  // ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙØµÙ„ Ø¨Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ù…Ø¯Ù…Ø¬Ø©
  chapter.translated = results.join('\n\n');
}

/* ------------------- Ø¥Ø¹Ø§Ø¯Ø© Ø¨Ù†Ø§Ø¡ EPUB ------------------- */
function escapeHtml(s){ return s.replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;').replaceAll('"','&quot;').replaceAll("'",'&#39;'); }
function normalizePath(p){ return p.replace(/\\/g,'/').replace(/^\.\//,'').toLowerCase(); }

async function buildTranslatedEpub(originalZip, chapters, title){
  setProgress(92, 'ÙŠØ¨Ù†ÙŠ Ù…Ù„Ù EPUB Ø§Ù„Ù…ØªØ±Ø¬Ù… ...');
  const out = new JSZip();
  // ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ù‡Ø°Ø§ Ø¨Ø¯ÙˆÙ† Ø¶ØºØ·
  out.file('mimetype', 'application/epub+zip', {compression: 'STORE'}); 

  for(const path of Object.keys(originalZip.files)){
    const f = originalZip.file(path);
    if(!f) continue;
    
    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ù…Ù„Ù Ù‡Ùˆ ÙØµÙ„ (XHTML/HTML) ÙˆÙ…ÙˆØ¬ÙˆØ¯ ÙÙŠ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ÙØµÙˆÙ„
    const found = chapters.find(c => normalizePath(c.href) === normalizePath(path));
    
    if(found && found.translated){
      // Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ù…Ù„Ù XHTML Ø¨Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù…ØªØ±Ø¬Ù…
      const bodyHtml = found.translated.split('\n\n').map(p => {
        // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ù‚Ø·Ø¹ Ù‡Ùˆ Ø¹Ù„Ø§Ù…Ø© Ø®Ø·Ø£ØŒ Ù†Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù†Øµ Ø§Ù„Ø£ØµÙ„ÙŠ Ù„Ø¹Ø¯Ù… Ø®Ø³Ø§Ø±Ø© Ø§Ù„Ù…Ø­ØªÙˆÙ‰
        if(p.includes('[Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ±Ø¬Ù…Ø© - Ø³ÙŠØªÙ… Ø¥Ø¯Ø±Ø§Ø¬Ù‡ ÙƒÙ†Øµ Ø£ØµÙ„ÙŠ ÙÙŠ EPUB]')) {
             return `<p style="color:red; font-size: 0.8em;">[**Ø®Ø·Ø£ ÙÙŠ ØªØ±Ø¬Ù…Ø© Ù‡Ø°Ø§ Ø§Ù„Ù…Ù‚Ø·Ø¹ØŒ ØªÙ… Ø¥Ø¯Ø±Ø§Ø¬ Ø§Ù„Ù†Øµ Ø§Ù„Ø£ØµÙ„ÙŠ Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù†Ù‡**]</p><p dir="ltr" lang="en">${escapeHtml(found.rawText)}</p>`;
        }
        return `<p dir="rtl" lang="ar">${escapeHtml(p)}</p>`;
      }).join('\n');
      
      // Ù†Ø¨Ø­Ø« Ø¹Ù† ÙˆØ³Ù… <body> Ø§Ù„Ø£ØµÙ„ÙŠ Ù„Ø¥Ø¯Ø±Ø§Ø¬ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù…ØªØ±Ø¬Ù… Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­
      const originalHtml = await f.async('text');
      let xhtml = originalHtml;
      
      const bodyStart = originalHtml.indexOf('<body>');
      const bodyEnd = originalHtml.indexOf('</body>');

      if (bodyStart !== -1 && bodyEnd !== -1 && bodyStart < bodyEnd) {
          // Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø¬Ø³Ù…
          xhtml = originalHtml.substring(0, bodyStart + 6) + 
                  `\n<div dir="rtl" lang="ar">${bodyHtml}</div>\n` + 
                  originalHtml.substring(bodyEnd);
          // Ù…Ø­Ø§ÙˆÙ„Ø© Ø¥Ø¶Ø§ÙØ© Ø®Ø§ØµÙŠØ© dir="rtl" Ùˆ lang="ar" Ù„Ù„Ù€ <html> Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø©
          if (!xhtml.includes('dir="rtl"')) {
             xhtml = xhtml.replace('<html', '<html dir="rtl" lang="ar"');
          }
      } else {
        // ÙƒØ­Ù„ Ø§Ø­ØªÙŠØ§Ø·ÙŠ Ø¨Ø³ÙŠØ· Ø¥Ø°Ø§ Ù„Ù… ÙŠÙØ¹Ø«Ø± Ø¹Ù„Ù‰ ÙˆØ³Ù… <body>
        xhtml = `<?xml version="1.0" encoding="utf-8"?>\n<html xmlns="http://www.w3.org/1999/xhtml" dir="rtl" lang="ar"><head><meta charset="utf-8"/><title>${title}</title></head><body>\n<div dir="rtl" lang="ar">${bodyHtml}</div>\n</body></html>`;
      }
      
      out.file(path, xhtml);
    } else {
      // Ù†Ø³Ø® Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø£ØµÙ„ÙŠ (Ø¨Ù…Ø§ ÙÙŠ Ø°Ù„Ùƒ OPF ÙˆØ§Ù„Ù€ CSS ÙˆØ§Ù„ØµÙˆØ±)
      const content = await f.async('uint8array');
      out.file(path, content);
    }
  }

  const blob = await out.generateAsync({type:'blob', mimeType:'application/epub+zip'});
  return blob;
}


/* ------------------- Ø§Ù„Ù…Ø¬Ø±Ù‰ Ø§Ù„ÙƒØ§Ù…Ù„ Ù…Ø¹ Ù…Ù†Ø·Ù‚ Ø§Ù„Ø§Ø³ØªØ¦Ù†Ø§Ù ------------------- */
async function startWorkflow(){
  try {
    if(!epubFile) { writeLog('âŒ Ù„Ù… ØªØ®ØªÙØ± Ù…Ù„Ù EPUB', 'error'); return; }
    const apiKey = qs('apiKey').value.trim();
    if(!apiKey) { writeLog('âŒ Ø£Ù„ØµÙ‚ Ù…ÙØªØ§Ø­ API Ø£ÙˆÙ„Ù‹Ø§', 'error'); return; }
    
    startBtn.disabled = true;
    setProgress(1, 'ÙŠØ¬Ù‡Ø² Ø§Ù„Ø¹Ù…Ù„ÙŠØ©...');
    
    let state = localStorage.getItem(STORAGE_KEY);
    state = state ? JSON.parse(state) : null;
    
    let initialChapterIndex = 0;
    let zip, opfPath, chapters;
    
    // Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ù…Ù† Ø­Ø§Ù„Ø© Ø§Ù„Ø§Ø³ØªØ¦Ù†Ø§Ù
    const isResuming = (state && state.filename === epubFile.name && state.apiKey === apiKey && Array.isArray(state.chapters));

    if (isResuming) {
        // Ø­Ø§Ù„Ø© Ø§Ø³ØªØ¦Ù†Ø§Ù
        zip = await JSZip.loadAsync(epubFile);
        opfPath = state.opfPath;
        chapters = state.chapters;
        
        // Ø¬Ù„Ø¨ Ø§Ù„Ù†Øµ Ø§Ù„Ø£ØµÙ„ÙŠ Ù„Ù„ÙØµÙˆÙ„ ØºÙŠØ± Ø§Ù„Ù…ØªØ±Ø¬Ù…Ø© (Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ±Ø¬Ù…Ø©)
        const tempResult = await readOpfAndCollect(zip, opfPath);
        chapters.forEach((c, i) => {
            if (c.translated === null && tempResult.chapters[i]) {
                c.rawHtml = tempResult.chapters[i].rawHtml;
                c.rawText = tempResult.chapters[i].rawText;
            } else if(c.translated) {
                // Ù‚Ø¯ Ù„Ø§ Ù†Ø­ØªØ§Ø¬ Ø§Ù„Ù†Øµ Ø§Ù„Ø£ØµÙ„ÙŠ Ù„Ù„ÙØµÙˆÙ„ Ø§Ù„Ù…ØªØ±Ø¬Ù…Ø©ØŒ Ù„ÙƒÙ† ÙŠØ¬Ø¨ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¬ÙˆØ¯Ù‡ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù‡Ù†Ø§Ùƒ Ù…Ø´ÙƒÙ„Ø©
            }
        });

        initialChapterIndex = chapters.findIndex(c => c.translated === null);
        if (initialChapterIndex === -1) initialChapterIndex = chapters.length;
        writeLog(`âœ… Ø§Ø³ØªØ¦Ù†Ø§Ù: ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø­Ø§Ù„Ø©ØŒ Ø§Ù„Ø¨Ø¯Ø¡ Ù…Ù† Ø§Ù„ÙØµÙ„ ${initialChapterIndex + 1} Ù…Ù† ${chapters.length}`, 'ok');
    } else {
        // Ø­Ø§Ù„Ø© Ø¨Ø¯Ø¡ Ø¬Ø¯ÙŠØ¯
        writeLog('ğŸ” ÙŠØ¨Ø¯Ø£ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„ÙƒØªØ§Ø¨...');
        const extractionResult = await extractChaptersFromEpub(epubFile);
        zip = extractionResult.zip; opfPath = extractionResult.opfPath; chapters = extractionResult.chapters;
        initialChapterIndex = 0;
        // Ø­ÙØ¸ Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø£ÙˆÙ„ÙŠØ© ÙÙŠ Local Storage (ÙØµÙˆÙ„ ÙØ§Ø±ØºØ©)
        saveState({ filename: epubFile.name, apiKey, opfPath, chapters });
    }

    setProgress(8, 'Ù…Ø³ØªØ®Ù„Øµ Ø§Ù„ÙØµÙˆÙ„ â€” ÙŠØ¨Ø¯Ø£ Ø§Ù„ØªØ±Ø¬Ù…Ø© ÙØµÙ„Ù‹Ø§ ÙØµÙ„Ù‹Ø§');
    
    // Ø§Ù„ØªØ±Ø¬Ù…Ø© ÙˆØ§Ù„Ø§Ø³ØªØ¦Ù†Ø§Ù
    for(let i = initialChapterIndex; i < chapters.length; i++){
        setProgress(10 + Math.round((i/chapters.length)*80), `ØªØ±Ø¬Ù…Ø© ÙØµÙ„ ${i+1}/${chapters.length}`);
        // Ù†Ù…Ø±Ø± Ø§Ù„Ù€ fewShot Ù…Ù† Ù…ØªØºÙŠØ±Ù‡Ø§ Ø§Ù„Ø¹Ø§Ù…
        await translateChapterWithChunks(chapters[i], i, chapters.length); 
        
        // Ø­ÙØ¸ Ø§Ù„Ø­Ø§Ù„Ø© Ø¨Ø¹Ø¯ ÙƒÙ„ ÙØµÙ„ ØªÙ… ØªØ±Ø¬Ù…ØªÙ‡
        saveState({ filename: epubFile.name, apiKey, opfPath, chapters });
    }

    // Ø¥Ø¹Ø§Ø¯Ø© Ø¨Ù†Ø§Ø¡ Ø§Ù„ÙƒØªØ§Ø¨ Ø¨Ø¹Ø¯ Ø§ÙƒØªÙ…Ø§Ù„ Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙØµÙˆÙ„
    const title = epubFile.name.replace(/\.[^/.]+$/, '') + '_Ù…ØªØ±Ø¬Ù…_Ø¢Ù„ÙŠ';
    const blob = await buildTranslatedEpub(zip, chapters, title);

    // Ø¥ØªØ§Ø­Ø© Ø±Ø§Ø¨Ø· Ø§Ù„ØªØ­Ù…ÙŠÙ„
    const url = URL.createObjectURL(blob);
    const a = qs('downloadLink'); a.href = url; a.download = title + '.epub'; a.style.display = 'inline-block';
    a.textContent = 'â¬‡ï¸ ØªÙ†Ø²ÙŠÙ„ EPUB Ø§Ù„Ù…ØªØ±Ø¬Ù…: ' + a.download;
    
    setProgress(100, 'Ø§ÙƒØªÙ…Ù„ â€” Ø§Ù†Ù‚Ø± ØªÙ†Ø²ÙŠÙ„');
    writeLog('ğŸ‰ Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø¢Ù„ÙŠØ© Ù„Ù€ ' + chapters.length + ' ÙØµÙ„ â€” ÙŠÙ…ÙƒÙ†Ùƒ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø¢Ù†', 'ok');
    localStorage.removeItem(STORAGE_KEY); // Ø¥Ø²Ø§Ù„Ø© Ø­Ø§Ù„Ø© Ø§Ù„Ø§Ø³ØªØ¦Ù†Ø§Ù Ø§Ù„Ù…ÙƒØªÙ…Ù„Ø©
    
  } catch(err){
    writeLog('âŒ ÙØ´Ù„ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©: ' + (err.message || err), 'error');
    setProgress(0, 'ÙØ´Ù„');
  } finally {
    startBtn.disabled = false;
    updateStartButton();
  }
}
</script>
</body>
</html>
