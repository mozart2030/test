<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Ù…ØªØ±Ø¬Ù… EPUB Ø§Ø­ØªØ±Ø§ÙÙŠ â€” Gemini PWA</title>
  
  <link rel="manifest" href="manifest.json">
  
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        // ØªØ£ÙƒØ¯ Ø£Ù† sw.js Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ Ù†ÙØ³ Ø§Ù„Ù…Ø¬Ù„Ø¯
        navigator.serviceWorker.register('sw.js')
          .then(reg => console.log('âœ… ØªÙ… ØªØ³Ø¬ÙŠÙ„ Service Worker Ø¨Ù†Ø¬Ø§Ø­.'))
          .catch(err => console.error('âŒ ÙØ´Ù„ ØªØ³Ø¬ÙŠÙ„ Service Worker:', err));
      });
    }
  </script>
  
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <style>
    body{font-family:system-ui, "Amiri", serif;background:#f5f7fb;padding:18px}
    .card{max-width:980px;margin:0 auto;background:white;padding:18px;border-radius:12px;box-shadow:0 10px 30px rgba(2,6,23,0.06)}
    h1{color:#0f5bd8}
    label{display:block;margin:8px 0;font-weight:600}
    input[type=text], input[type=file], button{width:100%;padding:10px;border-radius:8px;border:1px solid #d1d5db}
    .row{display:flex;gap:12px}
    .half{flex:1}
    #log{max-height:240px;overflow:auto;background:#fbfdff;padding:10px;border-radius:8px;border:1px solid #e6eefc}
    .progress{height:14px;background:#e6eefc;border-radius:999px;overflow:hidden}
    .bar{height:100%;width:0;background:#16a34a;transition:width .3s}
    .small{font-size:13px;color:#475569}
  </style>
</head>
<body>
  <div class="card">
    <h1>Ù…ØªØ±Ø¬Ù… EPUB Ø§Ø­ØªØ±Ø§ÙÙŠ â€” Gemini PWA</h1>
    <p class="small">Ù‡Ø°Ø§ ØªØ·Ø¨ÙŠÙ‚ ÙˆÙŠØ¨ ØªÙ‚Ø¯Ù…ÙŠ (PWA) ÙŠØ­Ø§ÙˆÙ„ Ø§Ù„Ø§Ø³ØªØ¦Ù†Ø§Ù Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ ÙÙŠ Ø­Ø§Ù„ Ø§Ù„Ø®Ø±ÙˆØ¬ ÙˆØ§Ù„Ø¹ÙˆØ¯Ø©. **Ù…Ù„Ø§Ø­Ø¸Ø©:** Ù„Ø§ ÙŠÙ…ÙƒÙ† ØªØ´ØºÙŠÙ„ Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø¹Ù†Ø¯ Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ù…ØªØµÙØ­ ØªÙ…Ø§Ù…Ø§Ù‹.</p>

    <label>1) Ù…ÙØªØ§Ø­ Gemini API (Google Generative Language) <span style="color:#c00">*</span></label>
    <input id="apiKey" type="text" placeholder="Ø£Ù„ØµÙ‚ Ù…ÙØªØ§Ø­ API Ù‡Ù†Ø§ (key)">

    <label>2) Ù…Ù„Ù Few-Shot JSON (Ø§Ø®ØªÙŠØ§Ø±ÙŠ) - Ù„ØªØ­Ø³ÙŠÙ† Ø£Ø³Ù„ÙˆØ¨ Ø§Ù„ØªØ±Ø¬Ù…Ø©</label>
    <input id="fewFile" type="file" accept=".json">

    <label>3) Ù…Ù„Ù EPUB (Ø§Ù„ÙƒØªØ§Ø¨ Ø§Ù„Ø°ÙŠ ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ 500 ÙØµÙ„)</label>
    <input id="epubFile" type="file" accept=".epub">

    <div style="margin-top:12px" class="row">
      <div class="half">
        <button id="startBtn">Ø§Ø¨Ø¯Ø£ Ø§Ù„ØªØ±Ø¬Ù…Ø©</button>
      </div>
      <div class="half">
        <a id="downloadLink" style="display:none;text-decoration:none" class="small">â¬‡ï¸ ØªÙ†Ø²ÙŠÙ„ EPUB Ø§Ù„Ù…ØªØ±Ø¬Ù…</a>
      </div>
    </div>

    <div style="margin-top:12px">
      <div class="progress"><div id="bar" class="bar"></div></div>
      <div id="status" class="small" style="margin-top:8px"></div>
      <div id="log" style="margin-top:12px"></div>
    </div>
  </div>

<script>
/* ================= Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„ØªØ¹Ø¯ÙŠÙ„ ================= */
// Ø§Ø³ØªØ®Ø¯Ø§Ù… Flash Ù„Ø³Ø±Ø¹Ø© Ø§Ù„ØªØ±Ø¬Ù…Ø©
const API_MODEL = "gemini-2.5-flash"; 
const API_BASE = "https://generativelanguage.googleapis.com/v1beta/models";
// ØªÙ… Ø§Ù„ØªØ¹Ø¯ÙŠÙ„: Ø±ÙØ¹ Ø­Ø¬Ù… Ø§Ù„Ù…Ù‚Ø·Ø¹ Ø¥Ù„Ù‰ 10,000 Ø­Ø±Ù Ù„Ø²ÙŠØ§Ø¯Ø© ÙƒÙØ§Ø¡Ø© API
const SAFE_CHAR_PER_CHUNK = 10000; 
// ØªÙ… Ø§Ù„ØªØ¹Ø¯ÙŠÙ„: Ø±ÙØ¹ Ø§Ù„ØªÙˆØ§Ø²ÙŠ Ø¥Ù„Ù‰ 8 Ù„Ù„Ø§Ù‚ØªØ±Ø§Ø¨ Ù…Ù† Ø­Ø¯ Ø§Ù„Ù€ RPM (10)
const MAX_CONCURRENCY = 8; 
// Ø¹Ø¯Ø¯ Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø§Ù„Ø§ØªØµØ§Ù„ Ø¹Ù†Ø¯ Ø§Ù„ÙØ´Ù„ Ø§Ù„Ù…Ø¤Ù‚Øª
const MAX_RETRIES = 5; 
const STORAGE_KEY = 'geminiTranslatorState'; // Ù…ÙØªØ§Ø­ Ø­ÙØ¸ Ø§Ù„Ø­Ø§Ù„Ø© Ù„Ù„Ø§Ø³ØªØ¦Ù†Ø§Ù
/* ===================================================== */

const qs = id => document.getElementById(id);
const logNode = qs('log'), statusNode = qs('status'), bar = qs('bar');
const startBtn = qs('startBtn');

let epubFile = null, fewShot = [];

qs('epubFile').addEventListener('change', e => { epubFile = e.target.files[0]; writeLog('ğŸ“¥ Ø§Ø®ØªØ±Øª: ' + (epubFile ? epubFile.name : 'Ù„Ø§ Ø´ÙŠØ¡')); updateStartButton(); });
qs('apiKey').addEventListener('input', updateStartButton);
qs('fewFile').addEventListener('change', async e => {
  const f = e.target.files[0]; if(!f) { fewShot = []; return; }
  try {
    const txt = await f.text();
    const parsed = JSON.parse(txt);
    if(!Array.isArray(parsed)) { writeLog('âŒ Ù…Ù„Ù few-shot ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ù…ØµÙÙˆÙØ©', 'error'); return; }
    // ØªØµØ­ÙŠØ­ Ø¨Ø³ÙŠØ· Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¨Ù†ÙŠØ©
    fewShot = parsed.filter(p => p && typeof p.en === 'string' && typeof p.ar === 'string');
    writeLog('âœ… Ø­Ù…Ù„Øª ' + fewShot.length + ' Ù†Ù…ÙˆØ°Ø¬ ØªØ±Ø¬Ù…Ø© (few-shot)');
    updateStartButton();
  } catch(err){ writeLog('âŒ Ø®Ø·Ø£ Ù‚Ø±Ø§Ø¡Ø© few-shot: ' + err.message, 'error'); fewShot = []; }
});

qs('startBtn').addEventListener('click', startWorkflow);

// ØªØ­Ø¯ÙŠØ« Ù†Øµ Ø²Ø± "Ø§Ù„Ø¨Ø¯Ø¡/Ø§Ù„Ø§Ø³ØªØ¦Ù†Ø§Ù"
function updateStartButton() {
    const key = qs('apiKey').value.trim();
    const file = qs('epubFile').files[0];
    const hasFewShot = fewShot.length > 0;
    
    startBtn.disabled = (!key || !file);

    if (!key || !file) {
        startBtn.textContent = 'Ø£Ø¯Ø®Ù„ Ø§Ù„Ù…ÙØªØ§Ø­ ÙˆØ§Ø®ØªØ± Ø§Ù„Ù…Ù„Ù';
        return;
    }
    
    let state = localStorage.getItem(STORAGE_KEY);
    state = state ? JSON.parse(state) : null;
    
    if (state && state.filename === file.name && state.apiKey === key && Array.isArray(state.chapters)) {
        const translatedCount = state.chapters.filter(c => c.translated).length;
        if (translatedCount < state.chapters.length) {
            startBtn.textContent = `Ø§Ø³ØªØ¦Ù†Ø§Ù Ø§Ù„ØªØ±Ø¬Ù…Ø© (${translatedCount}/${state.chapters.length}) - ${hasFewShot ? 'Ù…Ø¹ Few-Shot' : 'Ø¨Ø¯ÙˆÙ† Few-Shot'}`;
        } else {
            startBtn.textContent = 'Ø§ÙƒØªÙ…Ù„ Ø³Ø§Ø¨Ù‚Ø§Ù‹ (Ø§Ø¨Ø¯Ø£ Ù…Ù† Ø¬Ø¯ÙŠØ¯)';
        }
    } else {
        startBtn.textContent = hasFewShot ? 'Ø§Ø¨Ø¯Ø£ Ø§Ù„ØªØ±Ø¬Ù…Ø© (Ù…Ø¹ Few-Shot)' : 'Ø§Ø¨Ø¯Ø£ Ø§Ù„ØªØ±Ø¬Ù…Ø©';
    }
}
window.addEventListener('load', updateStartButton);


function writeLog(msg, type='info') {
  const p = document.createElement('div');
  p.textContent = `[${new Date().toLocaleTimeString('ar-EG')}] ${msg}`;
  if(type==='error') p.style.color='crimson';
  if(type==='ok') p.style.color='green';
  logNode.prepend(p);
}

function setProgress(p, txt='') { bar.style.width = Math.max(0,Math.min(100,p)) + '%'; statusNode.textContent = txt; }

/* ------------------- Ù…Ø³Ø§Ø¹Ø¯Ø©: Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ API Ù…Ø¹ Ø¥Ø¹Ø§Ø¯Ø© Ù…Ø­Ø§ÙˆÙ„Ø© ------------------- */
async function callGemini(promptText) {
  const key = qs('apiKey').value.trim();
  if(!key) throw new Error('Ù…ÙØªØ§Ø­ API Ù…ÙÙ‚ÙˆØ¯');
  const url = `${API_BASE}/${API_MODEL}:generateContent?key=${encodeURIComponent(key)}`;

  const payload = { contents: [{ parts: [{ text: promptText }] }] };

  let lastErr = null;
  for(let attempt=0; attempt < MAX_RETRIES; attempt++){
    try {
      const res = await fetch(url, { method: 'POST', headers: { 'Content-Type':'application/json' }, body: JSON.stringify(payload) });
      const j = await res.json().catch(()=>({}));
      if(res.ok){
        const cand = j?.candidates?.[0];
        if(cand?.content?.parts?.[0]?.text) return cand.content.parts[0].text;
        if(cand?.content?.text) return cand.content.text;
        // ÙØ´Ù„ ÙÙŠ Ø§Ø³ØªØ®Ù„Ø§Øµ Ø§Ù„Ù†Øµ Ù„ÙƒÙ† Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø© ÙƒØ§Ù†Øª 200
        throw new Error('ÙØ´Ù„ Ø§Ø³ØªØ®Ù„Ø§Øµ Ø§Ù„Ù†Øµ Ù…Ù† Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø©: ' + JSON.stringify(j));
      } else {
        lastErr = j?.error?.message || `HTTP ${res.status}`;
        if(res.status === 429 || res.status >= 500 || res.status === 400 && lastErr.includes('rate limit')){
          // 429 Ø£Ùˆ 5xx Ø£Ùˆ Rate Limit
          const wait = (2 ** attempt) * 800 + Math.floor(Math.random()*400);
          writeLog(`âš ï¸ Ø±Ù…Ø² ${res.status} - Ø®Ø·Ø£ Ù…Ø¤Ù‚Øª: Ø¥Ø¹Ø§Ø¯Ø© Ù…Ø­Ø§ÙˆÙ„Ø© #${attempt+1} Ø¨Ø¹Ø¯ ${Math.round(wait/1000)} Ø«`, 'error');
          await sleep(wait);
          continue;
        } else {
          // Ø®Ø·Ø£ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ù…Ø¹Ø§Ù„Ø¬ØªÙ‡ Ø¨Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© (Ù…Ø«Ù„ 401 Ù…ÙØªØ§Ø­ Ø®Ø§Ø·Ø¦)
          throw new Error(lastErr);
        }
      }
    } catch(err){
      lastErr = err.message || String(err);
      const wait = (2 ** attempt) * 600 + Math.floor(Math.random()*300);
      writeLog(`âš ï¸ Ø®Ø·Ø£ Ø§ØªØµØ§Ù„: ${lastErr} â€” Ø¥Ø¹Ø§Ø¯Ø© Ù…Ø­Ø§ÙˆÙ„Ø© #${attempt+1} Ø¨Ø¹Ø¯ ${Math.round(wait/1000)} Ø«`, 'error');
      await sleep(wait);
    }
  }
  throw new Error('ØªØ¬Ø§ÙˆØ²Ù†Ø§ Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø§Ù„Ø§ØªØµØ§Ù„ Ø§Ù„Ù…Ø³Ù…ÙˆØ­Ø©: ' + (lastErr||'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ'));
}

/* ------------------- ØªÙ‚Ø³ÙŠÙ… Ø°ÙƒÙŠ Ù„Ù„Ù†Øµ ------------------- */
function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }
// Ù‚Ø·Ø¹ Ø§Ù„Ù†Øµ Ø¹Ù†Ø¯ Ù†Ù‡Ø§ÙŠØ© ÙÙ‚Ø±Ø© Ø£Ùˆ Ø¬Ù…Ù„Ø© Ù„Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„Ø³ÙŠØ§Ù‚
function safeCut(text, start, maxChars) {
  const end = Math.min(text.length, start + maxChars);
  const snippet = text.substring(start, end);
  
  // ØªÙ… Ø§Ù„ØªØ¹Ø¯ÙŠÙ„: Ø´Ø±Ø· Ø§Ù„Ù‚Ø·Ø¹ ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø¨Ø¹Ø¯ 90% Ù…Ù† Ø­Ø¬Ù… Ø§Ù„Ù…Ù‚Ø·Ø¹ Ù„Ø²ÙŠØ§Ø¯Ø© ÙƒÙØ§Ø¡Ø© Ø§Ù„Ù€ 10000 Ø­Ø±Ù
  const minCutPoint = Math.max(50, maxChars * 0.90); 
  
  const lastPara = snippet.lastIndexOf('\n\n');
  if(lastPara > minCutPoint) return start + lastPara;
  
  const lastSentence = snippet.lastIndexOf('. ');
  if(lastSentence > minCutPoint) return start + lastSentence + 1;
  
  return end;
}
/* ------------------- Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…Ø­ØªÙˆÙŠØ§Øª EPUB Ø¨Ø·Ø±ÙŠÙ‚Ø© Ù…Ø±ØªØ¨Ø© ------------------- */
async function extractChaptersFromEpub(fileBlob){
  setProgress(2, 'ÙŠÙÙƒ Ø¶ØºØ· EPUB ÙˆÙŠØ­Ø¯Ø¯ Ù…Ù„Ù Ø§Ù„Ù…Ø­ØªÙˆÙ‰ (OPF)...');
  if (typeof JSZip === 'undefined') throw new Error('Ù…ÙƒØªØ¨Ø© JSZip Ù„Ù… ØªÙØ­Ù…Ù‘Ù„.');
  const zip = await JSZip.loadAsync(fileBlob);
  const containerPath = 'META-INF/container.xml';
  let opfPath;

  if(zip.file(containerPath)) {
    const contTxt = await zip.file(containerPath).async('text');
    const contDoc = new DOMParser().parseFromString(contTxt, 'application/xml');
    opfPath = contDoc.querySelector('rootfile')?.getAttribute('full-path');
  } else {
    writeLog('âš ï¸ Ù„Ù… Ø£Ø¬Ø¯ container.xml â€” Ø³Ø£Ø¨Ø­Ø« Ø¹Ù† Ù…Ù„Ù .opf Ù…Ø¨Ø§Ø´Ø±Ø©', 'error');
    opfPath = Object.keys(zip.files).find(p => p.toLowerCase().endsWith('.opf'));
  }
  
  if(!opfPath) throw new Error('Ù„Ù… ÙŠÙØ¹Ø«Ø± Ø¹Ù„Ù‰ Ù…Ù„Ù OPF Ù„ØªØ­Ø¯ÙŠØ¯ ØªØ±ØªÙŠØ¨ Ø§Ù„ÙØµÙˆÙ„');

  return await readOpfAndCollect(zip, opfPath);
}

async function readOpfAndCollect(zip, opfPath){
  setProgress(5, 'ÙŠÙ‚Ø±Ø£ content.opf ÙˆÙŠØ¬Ù…Ø¹ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ù„ÙØ§Øª ÙˆÙÙ‚ spine...');
  const opfTxt = await zip.file(opfPath).async('text');
  const opfDoc = new DOMParser().parseFromString(opfTxt, 'application/xml');

  const manifestItems = {};
  opfDoc.querySelectorAll('manifest > item').forEach(it=>{
    const id = it.getAttribute('id'), href = it.getAttribute('href');
    if(id && href) manifestItems[id] = href;
  });

  const spineItems = Array.from(opfDoc.querySelectorAll('spine > itemref')).map(it => it.getAttribute('idref')).filter(Boolean);
  const baseDir = opfPath.includes('/') ? opfPath.substring(0, opfPath.lastIndexOf('/')+1) : '';

  const chapters = [];
  for(const idref of spineItems){
    const href = manifestItems[idref];
    if(!href) continue;
    const full = baseDir + href;
    const fileEntry = zip.file(full) || zip.file(href);
    if(!fileEntry) continue;
    const txt = await fileEntry.async('text');
    const doc = new DOMParser().parseFromString(txt, 'text/html');
    // Ø§Ø³ØªÙ‡Ø¯Ø§Ù Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„ØªÙŠ ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ù…Ø­ØªÙˆÙ‰ Ù†ØµÙŠ Ù„ØªØ±Ø¬Ù…ØªÙ‡Ø§
    const nodes = Array.from(doc.querySelectorAll('body p, body div, body h1, body h2, body h3, body li'));
    const plain = nodes.map(n => n.textContent.trim()).filter(s=>s).join('\n\n');
    chapters.push({ href: full, rawHtml: txt, rawText: plain, translated: null }); // ØªÙ… Ø¥Ø¶Ø§ÙØ© translated: null Ù„Ù„Ø­ÙØ¸
  }

  if(chapters.length === 0) throw new Error('Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ ÙØµÙˆÙ„ Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬');
  writeLog('âœ… ØªÙ… Ø§Ø³ØªØ®Ø±Ø§Ø¬ ' + chapters.length + ' Ø¹Ù†ØµØ± (ÙØµÙ„/Ù‚Ø³Ù…) Ù…Ù† Ø§Ù„ÙƒØªØ§Ø¨', 'ok');
  return { zip, opfPath, chapters };
}

/* ------------------- Ø¯Ø§Ù„Ø© Ø­ÙØ¸ Ø§Ù„Ø­Ø§Ù„Ø© ÙÙŠ Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø­Ù„ÙŠ ------------------- */
function saveState(stateData) {
  try {
    // Ø­ÙØ¸ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¶Ø±ÙˆØ±ÙŠØ© ÙÙ‚Ø· Ù„Ù„Ø§Ø³ØªØ¦Ù†Ø§Ù
    const stateToSave = {
        filename: stateData.filename,
        apiKey: stateData.apiKey,
        opfPath: stateData.opfPath,
        chapters: stateData.chapters.map(c => ({ 
            href: c.href, 
            translated: c.translated || null // Ø­ÙØ¸ Ø§Ù„Ù†Øµ Ø§Ù„Ù…ØªØ±Ø¬Ù… Ø¥Ø°Ø§ ÙˆØ¬Ø¯
        }))
    };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(stateToSave));
    updateStartButton();
  } catch(e) {
    writeLog('âš ï¸ ÙØ´Ù„ Ø­ÙØ¸ Ø§Ù„Ø­Ø§Ù„Ø© ÙÙŠ LocalStorage', 'error');
  }
}

/* ------------------- ØªØ±Ø¬Ù…Ø© ÙØµÙ„ Ù…Ø¹ ØªØ¬Ø²Ø¦Ø© Ø°ÙƒÙŠØ© ------------------- */
async function translateChapterWithChunks(chapter, chapterIndex, totalChapters){
  const text = chapter.rawText || '';
  if(!text || text.length < 10) { chapter.translated = ''; return; }

  const safeChars = SAFE_CHAR_PER_CHUNK;
  const pieces = [];
  let cursor = 0;
  while(cursor < text.length){
    // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¯Ø§Ù„Ø© Ø§Ù„Ù‚Ø·Ø¹ Ø§Ù„Ø°ÙƒÙŠØ©
    const cutIndex = safeCut(text, cursor, safeChars);
    const part = text.substring(cursor, cutIndex).trim();
    if(part) pieces.push(part);
    cursor = cutIndex;
    if(cursor === text.length && pieces.length === 0) break;
  }
  
  if(pieces.length === 0 && text.length > 0) pieces.push(text); // ÙÙŠ Ø­Ø§Ù„ ÙƒØ§Ù† Ø§Ù„Ù†Øµ Ø£ØµØºØ± Ù…Ù† Ø­Ø¯ Ø§Ù„Ù‚Ø·Ø¹

  writeLog(`ğŸ” ÙØµÙ„ ${chapterIndex+1} Ù…Ù† ${totalChapters}: ØªÙ‚Ø·ÙŠØ¹ Ø¥Ù„Ù‰ ${pieces.length} Ù…Ù‚Ø·Ø¹(Ø§Øª)`);

  const results = new Array(pieces.length);
  let index = 0;

  let context = '';
  // Ø¥Ø¶Ø§ÙØ© Ø£Ù…Ø«Ù„Ø© Few-Shot Ù„Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© ÙÙŠ ØªØ­Ø¯ÙŠØ¯ Ø£Ø³Ù„ÙˆØ¨ Ø§Ù„ØªØ±Ø¬Ù…Ø©
  if (fewShot.length > 0) {
      context += "=== Ø£Ù…Ø«Ù„Ø© Few-Shot Ù„Ù„ØªØ±Ø¬Ù…Ø© (ÙŠØ¬Ø¨ ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø£Ø³Ù„ÙˆØ¨) ===\n";
      // Ù†Ø­Ø¯Ø¯ 5 Ø£Ù…Ø«Ù„Ø© ÙƒØ­Ø¯ Ø£Ù‚ØµÙ‰ Ù„Ø¶Ù…Ø§Ù† Ø¹Ø¯Ù… ØªØ¬Ø§ÙˆØ² Ø­Ø¬Ù… Ø§Ù„Ù…Ø·Ø§Ù„Ø¨Ø©
      fewShot.slice(0, 5).forEach(sample => { 
          context += `[Ø§Ù„Ù†Øµ Ø§Ù„Ø£ØµÙ„ÙŠ]: ${sample.en.replace(/\n/g, ' ')}\n[Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©]: ${sample.ar.replace(/\n/g, ' ')}\n---\n`;
      });
      context += "\n";
  }

  async function worker(){
    while(true){
      const i = index++;
      if(i >= pieces.length) break;
      const piece = pieces[i];
      
      // Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ù…Ø¹Ø¯Ù„ Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø·Ù„Ø¨ (Prompt)
      let prompt = context + 
        "**Ø§Ù„Ø¯ÙˆØ± ÙˆØ§Ù„ØªØ¹Ù„ÙŠÙ…Ø§Øª:** Ø£Ù†Øª Ù…ØªØ±Ø¬Ù… Ø±ÙˆØ§Ø¦ÙŠ Ù…Ø­ØªØ±Ù Ù…ØªØ®ØµØµ ÙÙŠ ØªØ±Ø¬Ù…Ø© Ù‚ØµØµ ÙˆØ±ÙˆØ§ÙŠØ§Øª Ø§Ù„Ø®ÙŠØ§Ù„ (Xianxia/Wuxia). ØªØ±Ø¬Ù… Ø§Ù„Ù…Ù‚Ø·Ø¹ Ø§Ù„ØªØ§Ù„ÙŠ Ø¥Ù„Ù‰ Ø¹Ø±Ø¨ÙŠØ© ÙØµØ­Ù‰ ÙˆØ£Ø¯Ø¨ÙŠØ©. ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙƒ:\n" +
        "1. **Ø§Ù„Ø§ØªØ³Ø§Ù‚:** Ø·Ø¨Ù‚ Ø£Ø³Ù„ÙˆØ¨ Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ù…ÙˆØ¶Ø­ ÙÙŠ Ø£Ù…Ø«Ù„Ø© Few-Shot Ø£Ø¹Ù„Ø§Ù‡ Ø¨Ø¯Ù‚Ø©.\n" +
        "2. **Ø§Ù„Ù‡ÙŠÙƒÙ„ÙŠØ©:** Ø­Ø§ÙØ¸ Ø¹Ù„Ù‰ Ù‡ÙŠÙƒÙ„ Ø§Ù„ÙÙ‚Ø±Ø§Øª Ø§Ù„Ø£ØµÙ„ÙŠØ© Ø¨Ø§Ù„Ø¶Ø¨Ø· (Ù„Ø§ ØªØ¶ÙŠÙ Ø£Ùˆ ØªØ¯Ù…Ø¬ ÙÙ‚Ø±Ø§Øª).\n" +
        "3. **Ø§Ù„Ù…ØµØ·Ù„Ø­Ø§Øª:** Ù„Ø§ ØªØªØ±Ø¬Ù… Ø§Ù„Ù…ØµØ·Ù„Ø­Ø§Øª Ø§Ù„ØªÙ‚Ù†ÙŠØ© Ø£Ùˆ Ø§Ù„Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ø®Ø§ØµØ© (Ù…Ø«Ù„ Qi, Dantian, Core Formation, Ø£Ùˆ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ø£Ù…Ø§ÙƒÙ†/Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„ØµÙŠÙ†ÙŠØ©).\n\n" +
        "**Ø§Ù„Ù…Ù‚Ø·Ø¹ Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ ØªØ±Ø¬Ù…ØªÙ‡:**\n" + piece + "\n\n**Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©:**";

      try {
        const out = await callGemini(prompt);
        results[i] = out ? out.trim() : '[ÙØ§Ø±Øº]';
        writeLog(`âœ… ØªØ±Ø¬Ù…Ø© Ù…Ù‚Ø·Ø¹ ${i+1}/${pieces.length} ÙÙŠ ÙØµÙ„ ${chapterIndex+1}`);
      } catch(err){
        writeLog(`âŒ ÙØ´Ù„ ØªØ±Ø¬Ù…Ø© Ù…Ù‚Ø·Ø¹ ${i+1} ÙÙŠ ÙØµÙ„ ${chapterIndex+1}: ${err.message}`, 'error');
        results[i] = '[Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ±Ø¬Ù…Ø© - Ø³ÙŠØªÙ… Ø¥Ø¯Ø±Ø§Ø¬Ù‡ ÙƒÙ†Øµ Ø£ØµÙ„ÙŠ ÙÙŠ EPUB]'; // ÙˆØ¶Ø¹ Ø¹Ù„Ø§Ù…Ø© Ø®Ø·Ø£
      }
      await sleep(120);
    }
  }

  // ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¹Ù…Ø§Ù„ Ø¨Ø§Ù„ØªÙˆØ§Ø²ÙŠ
  const workers = Array.from({length: MAX_CONCURRENCY}, () => worker());
  await Promise.all(workers);

  // ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙØµÙ„ Ø¨Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ù…Ø¯Ù…Ø¬Ø©
  chapter.translated = results.join('\n\n');
}

/* ------------------- Ø¥Ø¹Ø§Ø¯Ø© Ø¨Ù†Ø§Ø¡ EPUB ------------------- */
function escapeHtml(s){ return s.replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;').replaceAll('"','&quot;').replaceAll("'",'&#39;'); }
function normalizePath(p){ return p.replace(/\\/g,'/').replace(/^\.\//,'').toLowerCase(); }

async function buildTranslatedEpub(originalZip, chapters, title){
  setProgress(92, 'ÙŠØ¨Ù†ÙŠ Ù…Ù„Ù EPUB Ø§Ù„Ù…ØªØ±Ø¬Ù… ...');
  const out = new JSZip();
  // ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ù‡Ø°Ø§ Ø¨Ø¯ÙˆÙ† Ø¶ØºØ·
  out.file('mimetype', 'application/epub+zip', {compression: 'STORE'}); 

  for(const path of Object.keys(originalZip.files)){
    const f = originalZip.file(path);
    if(!f) continue;
    
    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ù…Ù„Ù Ù‡Ùˆ ÙØµÙ„ (XHTML/HTML) ÙˆÙ…ÙˆØ¬ÙˆØ¯ ÙÙŠ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ÙØµÙˆÙ„
    const found = chapters.find(c => normalizePath(c.href) === normalizePath(path));
    
    if(found && found.translated){
      // Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ù…Ù„Ù XHTML Ø¨Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù…ØªØ±Ø¬Ù…
      const bodyHtml = found.translated.split('\n\n').map(p => {
        // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ù‚Ø·Ø¹ Ù‡Ùˆ Ø¹Ù„Ø§Ù…Ø© Ø®Ø·Ø£ØŒ Ù†Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù†Øµ Ø§Ù„Ø£ØµÙ„ÙŠ Ù„Ø¹Ø¯Ù… Ø®Ø³Ø§Ø±Ø© Ø§Ù„Ù…Ø­ØªÙˆÙ‰
        if(p.includes('[Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ±Ø¬Ù…Ø© - Ø³ÙŠØªÙ… Ø¥Ø¯Ø±Ø§Ø¬Ù‡ ÙƒÙ†Øµ Ø£ØµÙ„ÙŠ ÙÙŠ EPUB]')) {
             return `<p style="color:red; font-size: 0.8em;">[**Ø®Ø·Ø£ ÙÙŠ ØªØ±Ø¬Ù…Ø© Ù‡Ø°Ø§ Ø§Ù„Ù…Ù‚Ø·Ø¹ØŒ ØªÙ… Ø¥Ø¯Ø±Ø§Ø¬ Ø§Ù„Ù†Øµ Ø§Ù„Ø£ØµÙ„ÙŠ Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù†Ù‡**]</p><p dir="ltr" lang="en">${escapeHtml(found.rawText)}</p>`;
        }
        return `<p dir="rtl" lang="ar">${escapeHtml(p)}</p>`;
      }).join('\n');
      
      // Ù†Ø¨Ø­Ø« Ø¹Ù† ÙˆØ³Ù… <body> Ø§Ù„Ø£ØµÙ„ÙŠ Ù„Ø¥Ø¯Ø±Ø§Ø¬ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù…ØªØ±Ø¬Ù… Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­
      const originalHtml = await f.async('text');
      let xhtml = originalHtml;
      
      const bodyStart = originalHtml.indexOf('<body>');
      const bodyEnd = originalHtml.indexOf('</body>');

      if (bodyStart !== -1 && bodyEnd !== -1 && bodyStart < bodyEnd) {
          // Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø¬Ø³Ù…
          xhtml = originalHtml.substring(0, bodyStart + 6) + 
                  `\n<div dir="rtl" lang="ar">${bodyHtml}</div>\n` + 
                  originalHtml.substring(bodyEnd);
          // Ù…Ø­Ø§ÙˆÙ„Ø© Ø¥Ø¶Ø§ÙØ© Ø®Ø§ØµÙŠØ© dir="rtl" Ùˆ lang="ar" Ù„Ù„Ù€ <html> Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø©
          if (!xhtml.includes('dir="rtl"')) {
             xhtml = xhtml.replace('<html', '<html dir="rtl" lang="ar"');
          }
      } else {
        // ÙƒØ­Ù„ Ø§Ø­ØªÙŠØ§Ø·ÙŠ Ø¨Ø³ÙŠØ· Ø¥Ø°Ø§ Ù„Ù… ÙŠÙØ¹Ø«Ø± Ø¹Ù„Ù‰ ÙˆØ³Ù… <body>
        xhtml = `<?xml version="1.0" encoding="utf-8"?>\n<html xmlns="http://www.w3.org/1999/xhtml" dir="rtl" lang="ar"><head><meta charset="utf-8"/><title>${title}</title></head><body>\n<div dir="rtl" lang="ar">${bodyHtml}</div>\n</body></html>`;
      }
      
      out.file(path, xhtml);
    } else {
      // Ù†Ø³Ø® Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø£ØµÙ„ÙŠ (Ø¨Ù…Ø§ ÙÙŠ Ø°Ù„Ùƒ OPF ÙˆØ§Ù„Ù€ CSS ÙˆØ§Ù„ØµÙˆØ±)
      const content = await f.async('uint8array');
      out.file(path, content);
    }
  }

  const blob = await out.generateAsync({type:'blob', mimeType:'application/epub+zip'});
  return blob;
}


/* ------------------- Ø§Ù„Ù…Ø¬Ø±Ù‰ Ø§Ù„ÙƒØ§Ù…Ù„ Ù…Ø¹ Ù…Ù†Ø·Ù‚ Ø§Ù„Ø§Ø³ØªØ¦Ù†Ø§Ù ------------------- */
async function startWorkflow(){
  try {
    if(!epubFile) { writeLog('âŒ Ù„Ù… ØªØ®ØªÙØ± Ù…Ù„Ù EPUB', 'error'); return; }
    const apiKey = qs('apiKey').value.trim();
    if(!apiKey) { writeLog('âŒ Ø£Ù„ØµÙ‚ Ù…ÙØªØ§Ø­ API Ø£ÙˆÙ„Ù‹Ø§', 'error'); return; }
    
    startBtn.disabled = true;
    setProgress(1, 'ÙŠØ¬Ù‡Ø² Ø§Ù„Ø¹Ù…Ù„ÙŠØ©...');
    
    let state = localStorage.getItem(STORAGE_KEY);
    state = state ? JSON.parse(state) : null;
    
    let initialChapterIndex = 0;
    let zip, opfPath, chapters;
    
    // Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ù…Ù† Ø­Ø§Ù„Ø© Ø§Ù„Ø§Ø³ØªØ¦Ù†Ø§Ù
    const isResuming = (state && state.filename === epubFile.name && state.apiKey === apiKey && Array.isArray(state.chapters));

    if (isResuming) {
        // Ø­Ø§Ù„Ø© Ø§Ø³ØªØ¦Ù†Ø§Ù
        zip = await JSZip.loadAsync(epubFile);
        opfPath = state.opfPath;
        chapters = state.chapters;
        
        // Ø¬Ù„Ø¨ Ø§Ù„Ù†Øµ Ø§Ù„Ø£ØµÙ„ÙŠ Ù„Ù„ÙØµÙˆÙ„ ØºÙŠØ± Ø§Ù„Ù…ØªØ±Ø¬Ù…Ø© (Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ±Ø¬Ù…Ø©)
        const tempResult = await readOpfAndCollect(zip, opfPath);
        chapters.forEach((c, i) => {
            if (c.translated === null && tempResult.chapters[i]) {
                c.rawHtml = tempResult.chapters[i].rawHtml;
                c.rawText = tempResult.chapters[i].rawText;
            } else if(c.translated) {
                // Ù‚Ø¯ Ù„Ø§ Ù†Ø­ØªØ§Ø¬ Ø§Ù„Ù†Øµ Ø§Ù„Ø£ØµÙ„ÙŠ Ù„Ù„ÙØµÙˆÙ„ Ø§Ù„Ù…ØªØ±Ø¬Ù…Ø©ØŒ Ù„ÙƒÙ† ÙŠØ¬Ø¨ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¬ÙˆØ¯Ù‡ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù‡Ù†Ø§Ùƒ Ù…Ø´ÙƒÙ„Ø©
            }
        });

        initialChapterIndex = chapters.findIndex(c => c.translated === null);
        if (initialChapterIndex === -1) initialChapterIndex = chapters.length;
        writeLog(`âœ… Ø§Ø³ØªØ¦Ù†Ø§Ù: ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø­Ø§Ù„Ø©ØŒ Ø§Ù„Ø¨Ø¯Ø¡ Ù…Ù† Ø§Ù„ÙØµÙ„ ${initialChapterIndex + 1} Ù…Ù† ${chapters.length}`, 'ok');
    } else {
        // Ø­Ø§Ù„Ø© Ø¨Ø¯Ø¡ Ø¬Ø¯ÙŠØ¯
        writeLog('ğŸ” ÙŠØ¨Ø¯Ø£ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„ÙƒØªØ§Ø¨...');
        const extractionResult = await extractChaptersFromEpub(epubFile);
        zip = extractionResult.zip; opfPath = extractionResult.opfPath; chapters = extractionResult.chapters;
        initialChapterIndex = 0;
        // Ø­ÙØ¸ Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø£ÙˆÙ„ÙŠØ© ÙÙŠ Local Storage (ÙØµÙˆÙ„ ÙØ§Ø±ØºØ©)
        saveState({ filename: epubFile.name, apiKey, opfPath, chapters });
    }

    setProgress(8, 'Ù…Ø³ØªØ®Ù„Øµ Ø§Ù„ÙØµÙˆÙ„ â€” ÙŠØ¨Ø¯Ø£ Ø§Ù„ØªØ±Ø¬Ù…Ø© ÙØµÙ„Ù‹Ø§ ÙØµÙ„Ù‹Ø§');
    
    // Ø§Ù„ØªØ±Ø¬Ù…Ø© ÙˆØ§Ù„Ø§Ø³ØªØ¦Ù†Ø§Ù
    for(let i = initialChapterIndex; i < chapters.length; i++){
        setProgress(10 + Math.round((i/chapters.length)*80), `ØªØ±Ø¬Ù…Ø© ÙØµÙ„ ${i+1}/${chapters.length}`);
        // Ù†Ù…Ø±Ø± Ø§Ù„Ù€ fewShot Ù…Ù† Ù…ØªØºÙŠØ±Ù‡Ø§ Ø§Ù„Ø¹Ø§Ù…
        await translateChapterWithChunks(chapters[i], i, chapters.length); 
        
        // Ø­ÙØ¸ Ø§Ù„Ø­Ø§Ù„Ø© Ø¨Ø¹Ø¯ ÙƒÙ„ ÙØµÙ„ ØªÙ… ØªØ±Ø¬Ù…ØªÙ‡
        saveState({ filename: epubFile.name, apiKey, opfPath, chapters });
    }

    // Ø¥Ø¹Ø§Ø¯Ø© Ø¨Ù†Ø§Ø¡ Ø§Ù„ÙƒØªØ§Ø¨ Ø¨Ø¹Ø¯ Ø§ÙƒØªÙ…Ø§Ù„ Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙØµÙˆÙ„
    const title = epubFile.name.replace(/\.[^/.]+$/, '') + '_Ù…ØªØ±Ø¬Ù…_Ø¢Ù„ÙŠ';
    const blob = await buildTranslatedEpub(zip, chapters, title);

    // Ø¥ØªØ§Ø­Ø© Ø±Ø§Ø¨Ø· Ø§Ù„ØªØ­Ù…ÙŠÙ„
    const url = URL.createObjectURL(blob);
    const a = qs('downloadLink'); a.href = url; a.download = title + '.epub'; a.style.display = 'inline-block';
    a.textContent = 'â¬‡ï¸ ØªÙ†Ø²ÙŠÙ„ EPUB Ø§Ù„Ù…ØªØ±Ø¬Ù…: ' + a.download;
    
    setProgress(100, 'Ø§ÙƒØªÙ…Ù„ â€” Ø§Ù†Ù‚Ø± ØªÙ†Ø²ÙŠÙ„');
    writeLog('ğŸ‰ Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø¢Ù„ÙŠØ© Ù„Ù€ ' + chapters.length + ' ÙØµÙ„ â€” ÙŠÙ…ÙƒÙ†Ùƒ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø¢Ù†', 'ok');
    localStorage.removeItem(STORAGE_KEY); // Ø¥Ø²Ø§Ù„Ø© Ø­Ø§Ù„Ø© Ø§Ù„Ø§Ø³ØªØ¦Ù†Ø§Ù Ø§Ù„Ù…ÙƒØªÙ…Ù„Ø©
    
  } catch(err){
    writeLog('âŒ ÙØ´Ù„ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©: ' + (err.message || err), 'error');
    setProgress(0, 'ÙØ´Ù„');
  } finally {
    startBtn.disabled = false;
    updateStartButton();
  }
}
</script>
</body>
</html>
